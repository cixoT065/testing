<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Idle RPG Evolved</title>
    <style>
        :root {
            --bg-color: #0a0a0a;
            --panel-bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --primary-color: #444444;
            /* Enabled button color */
            --secondary-color: #333333;
            --border-color: #2c2c2c;
            --header-bg-color: #000000;
            --hp-color: #543232;
            --xp-color: #323954;
            --gold-color: #c7a552;
            --rebirth-color: #724394;
            --disabled-bg-color: #222222;
            --disabled-text-color: #555555;
            --skill-color: #ffffff;
            --stat-str: #c97d7d;
            --stat-con: #7dc982;
            --stat-def: #7d8ec9;
            --stat-dex: #c9c27d;
            --stat-agl: #c99b7d;
            --stat-int: #a37dc9;
            --set-bonus-active: #63C270;
            --selection-color: #61afef;
            --stat-increase-color: #98c379;
            --stat-decrease-color: #e06c75;
            --enhancement-color: #e06c75;
            --boost-color: #83c97d;
        }

        body {
            font-family: 'Verdana', 'Geneva', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            font-size: 14px;
        }

        .main-container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 280px;
            background-color: var(--panel-bg-color);
            border-right: 1px solid var(--border-color);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            flex-shrink: 0;
            min-height: 0; /* <-- Add this line here as well */
        }

        .main-content {
            flex-grow: 1;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            min-height: 0; /* <-- Add this line */
        }

        .panel {
            background-color: var(--panel-bg-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: inset 0 0 10px #000;
        }

        .panel-footer {
            padding: 10px;
            border-top: 1px solid var(--border-color);
            background-color: var(--header-bg-color);
            display: flex;
            gap: 10px;
        }

        #system-panel {
            margin-top: auto;
        }

        .panel-header {
            background-color: var(--header-bg-color);
            padding: 10px 15px;
            font-weight: bold;
            border-bottom: 1px solid var(--border-color);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 13px;
        }

        .panel-body {
            padding: 15px;
        }

        .stat-bar {
            background-color: #0a0a0a;
            border-radius: 2px;
            overflow: hidden;
            margin: 5px 0 10px;
            height: 20px;
            border: 1px solid #000;
        }

        .stat-bar-fill {
            height: 100%;
            transition: width 0.3s ease-in-out;
            text-align: center;
            font-size: 12px;
            line-height: 20px;
            color: #000;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.1);
        }

        #player-hp-fill {
            background-color: var(--hp-color);
        }

        #player-xp-fill {
            background-color: var(--xp-color);
        }

        #monster-hp-fill {
            background-color: #999999;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px 12px;
            font-size: 13px;
        }

        .monster-area {
            text-align: center;
        }

        #monster-name {
            font-size: 1.5em;
            font-weight: bold;
            margin: 20px 0;
            color: #ffffff;
        }

        .activity-log-container {
            overflow-y: auto;
            border: 1px solid #000;
            padding: 10px;
            background-color: #111;
            border-radius: 3px;
            flex-grow: 1;
        }

        .activity-log-container p {
            margin: 0 0 5px;
            font-size: 13px;
        }

        #global-tooltip {
            display: none;
            position: fixed;
            background-color: #111;
            color: var(--text-color);
            padding: 10px;
            border-radius: 4px;
            z-index: 1000;
            width: 250px;
            font-size: 13px;
            border: 1px solid var(--border-color);
            white-space: pre-wrap;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            pointer-events: auto;
        }
        
        .stat-increase { color: var(--stat-increase-color); }
        .stat-decrease { color: var(--stat-decrease-color); }
        .enhancement-bonus { color: var(--enhancement-color); }

        button,
        .button {
            background-color: var(--primary-color);
            color: var(--text-color);
            border: 1px solid #000;
            padding: 8px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.2s;
            width: 100%;
            margin-top: 5px;
            text-align: center;
            display: inline-block;
            box-sizing: border-box;
        }

        button:hover:not(:disabled) {
            background-color: #555555;
        }

        button:disabled {
            background-color: var(--disabled-bg-color);
            color: var(--disabled-text-color);
            cursor: not-allowed;
        }

        .button-secondary {
            background-color: var(--secondary-color);
            color: var(--text-color);
        }

        .button-secondary:hover:not(:disabled) {
            background-color: #444444;
        }

        .button-danger {
            background-color: #505050;
            color: var(--text-color);
        }

        .button-danger:hover:not(:disabled) {
            background-color: #616161;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: var(--panel-bg-color);
            margin: auto;
            padding: 30px;
            border: 1px solid var(--border-color);
            width: 80%;
            max-width: 500px;
            border-radius: 4px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        .modal-choices {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        .modal-choices button {
            width: auto;
            padding: 12px 20px;
            border: 2px solid transparent;
        }
        
        .modal-choices button.selected {
            border-color: var(--selection-color);
            background-color: #555;
        }

        .modal-description {
            min-height: 60px;
            margin-top: 20px;
            padding: 10px;
            background-color: var(--header-bg-color);
            border-radius: 3px;
            border: 1px solid var(--border-color);
            color: #b0b0b0;
            font-style: italic;
        }
        
        .modal-footer-confirm {
            margin-top: 20px;
        }

        #manual-save-textarea {
            width: 100%;
            height: 120px;
            background-color: #0a0a0a;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            margin: 15px 0;
            font-family: monospace;
            font-size: 12px;
            word-break: break-all;
        }

        .gold-display {
            font-size: 1.2em;
            color: var(--gold-color);
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
        }

        /* Log Colors */
        .log-player { color: #c5c5c5; }
        .log-monster { color: #e06c75; }
        .log-system { color: #9e9e9e; font-style: italic; }
        .log-drop { color: #d7ba7d; }
        .log-error { color: #ff6b6b; font-weight: bold; }
        .log-skill { color: #61afef; font-weight: bold; }
        .log-boost { color: var(--boost-color); font-weight: bold; }


        .point-investment-stat,
        .rebirth-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .point-investment-stat .stat-label {
            flex-grow: 1;
        }

        .investment-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .investment-controls button {
            width: 28px;
            height: 28px;
            padding: 0;
            font-size: 1.2em;
            flex-shrink: 0;
            margin: 0;
        }

        .pending-points {
            font-weight: bold;
            color: var(--gold-color);
            min-width: 20px;
            text-align: center;
        }

        .stat-value {
            color: var(--rebirth-color);
            font-weight: bold;
        }

        .equipment-slot-display {
            padding: 4px 0;
            position: relative;
            cursor: pointer;
        }

        .tab-buttons {
            display: flex;
            padding: 0;
            border-bottom: 1px solid var(--border-color);
        }

        .tab-button, .log-tab-button {
            flex: 1;
            border: none;
            background-color: var(--panel-bg-color);
            color: var(--text-color);
            padding: 10px;
            cursor: pointer;
            transition: background-color 0.2s, border-bottom-color 0.2s;
            border-radius: 0;
            margin: 0;
            border-bottom: 3px solid transparent;
        }

        .tab-button.active, .log-tab-button.active {
            border-bottom-color: var(--text-color);
            font-weight: bold;
            background-color: var(--header-bg-color);
        }

        .tab-content, .log-tab-content {
            display: none;
        }

        .tab-content.active, .log-tab-content.active {
            display: block;
        }

        #inventory-list {
            max-height: 250px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .inventory-item {
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
            position: relative;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .inventory-item-info {
            cursor: pointer;
            flex-grow: 1;
        }

        .inventory-item-actions {
            display: flex;
            gap: 5px;
            flex-shrink: 0;
        }

        .inventory-item-actions button {
            width: auto;
            padding: 4px 8px;
            font-size: 11px;
            margin-top: 0;
        }

        .equipped-tag {
            color: #ffffff;
            font-size: 0.8em;
            margin-left: 8px;
            font-style: italic;
            font-weight: bold;
        }

        .tooltip-button {
            width: 100%;
            box-sizing: border-box;
            padding: 6px;
            margin-top: 10px;
            font-size: 12px;
        }

        #skill-display .skill-entry {
            margin-bottom: 10px;
        }

        #skill-display strong {
            color: var(--skill-color);
            font-size: 14px;
        }

        #skill-display p {
            margin: 5px 0 0;
            font-style: italic;
            color: #ccc;
            font-size: 12px;
        }

        .shop-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
        }

        .shop-item {
            border: 1px solid var(--border-color);
            border-radius: 3px;
            padding: 10px;
            text-align: center;
            background-color: var(--header-bg-color);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .shop-item button {
            margin-top: 10px;
        }

        #xp-boost-status {
            color: var(--boost-color);
            font-weight: bold;
            margin-top: 10px;
            text-align: center;
            border: 1px solid var(--boost-color);
            padding: 5px;
            border-radius: 3px;
            background-color: rgba(131, 201, 125, 0.1);
        }

        /* Blacksmith Styles */
        #blacksmith-item-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .blacksmith-slot {
            flex: 1;
            padding: 10px;
            border: 2px solid var(--border-color);
            border-radius: 3px;
            cursor: pointer;
            text-align: center;
            background-color: var(--header-bg-color);
            transition: border-color 0.2s;
        }

        .blacksmith-slot.selected {
            border-color: var(--selection-color);
        }

        #blacksmith-enhancement-panel {
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background-color: var(--header-bg-color);
        }

        #enhancement-info {
            text-align: left;
        }

        #enhancement-info p {
            margin: 5px 0;
        }

        @media (max-width: 900px) {
            .main-container {
                flex-direction: column;
                height: auto;
                padding: 10px;
            }

            .sidebar {
                display: contents;
            }

            .main-content {
                order: 1;
                padding: 0;
            }

            .panel {
                width: auto;
                margin-bottom: 15px;
            }

            #system-panel {
                order: 99;
                margin-top: 0;
                margin-bottom: 0;
            }
        }
    </style>
</head>

<body>

    <div class="main-container">
        <div class="sidebar">
            <div class="panel">
                <div class="panel-header">Player Profile</div>
                <div class="panel-body">
                    <div id="player-info">
                        <div>Name: <span id="player-name">Player</span></div>
                        <div>Class: <span id="player-class">N/A</span></div>
                        <div>Level: <span id="player-level">1</span></div>
                        <div>Stat Points: <span id="player-stat-points" style="color: var(--gold-color); font-weight: bold;">0</span></div>
                    </div>
                    <hr style="border-color: var(--border-color);">
                    <div>HP (CON): <span id="player-hp-text">100 / 100</span></div>
                    <div class="stat-bar">
                        <div class="stat-bar-fill" id="player-hp-fill"></div>
                    </div>
                    <div>XP: <span id="player-xp-text">0 / 100</span></div>
                    <div class="stat-bar">
                        <div class="stat-bar-fill" id="player-xp-fill"></div>
                    </div>
                    <div id="xp-boost-status" style="display: none;"></div>
                    <div class="gold-display">Gold: <span id="player-gold">0</span>G</div>
                </div>
            </div>
            <div class="panel">
                <div class="panel-header">Combat Stats</div>
                <div class="panel-body stats-grid">
                    <div>ATK (STR/INT): <span id="player-atk">10</span></div>
                    <div>DEF (DEF): <span id="player-def">5</span></div>
                    <div>Accuracy (DEX): <span id="player-accuracy">5%</span></div>
                    <div>Evasion (AGL): <span id="player-evasion">5%</span></div>
                    <div>Crit Chance: <span id="player-crit-chance">5%</span></div>
                    <div>Crit DMG: <span id="player-crit-dmg">150%</span></div>
                </div>
            </div>
            <div class="panel">
                <div class="panel-header">Invest Points</div>
                <div class="panel-body" id="point-investment-display">
                    <!-- Dynamic content here -->
                </div>
                <div class="panel-footer" id="investment-actions">
                    <button id="confirm-invest-btn">Confirm</button>
                    <button id="reset-invest-btn" class="button-secondary">Reset</button>
                </div>
            </div>
            <div class="panel">
                <div class="panel-header">Equipment</div>
                <div class="panel-body" id="equipment-display"></div>
            </div>
            <div class="panel" id="skill-panel" style="display: none;">
                <div class="panel-header">Active Skills</div>
                <div class="panel-body" id="skill-display"></div>
            </div>
            <div class="panel" id="system-panel">
                <div class="panel-header">System</div>
                <div class="panel-body" style="display: flex; flex-direction: column; gap: 10px;">
                    <button id="manual-save-btn">Export Save</button>
                    <button id="manual-load-btn">Import Save</button>
                    <hr style="border-color: var(--border-color);">
                    <button id="new-game-btn" class="button-danger">New Game</button>
                    <button id="rebirth-btn" class="button-danger" style="display: none;">Rebirth</button>
                </div>
            </div>
        </div>

        <div class="main-content">
            <!-- Combat Area - Always Visible -->
            <div class="panel monster-area">
                <div class="panel-body">
                    <h2 id="monster-name">Monster</h2>
                    <div>HP: <span id="monster-hp-text">50 / 50</span></div>
                    <div class="stat-bar">
                        <div class="stat-bar-fill" id="monster-hp-fill"></div>
                    </div>
                    <div>Wave: <span id="wave-counter">1</span> | Kills: <span id="kill-counter">0</span></div>
                    <button id="challenge-boss-btn" disabled>Challenge Boss</button>
                </div>
            </div>

            <!-- Tabs and Log Area -->
            <div class="panel">
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="shop">Shop</button>
                    <button class="tab-button" data-tab="inventory">Inventory</button>
                    <button class="tab-button" data-tab="blacksmith">Blacksmith</button>
                    <button class="tab-button" data-tab="rebirth">Rebirth</button>
                </div>
                <div class="panel-body">
                    <div id="tab-content-shop" class="tab-content active">
                        <div class="shop-grid">
                            <div class="shop-item">
                                <div>
                                    <strong>Minor Potion</strong>
                                    <p>Heals 25% HP</p>
                                </div>
                                <button id="buy-potion-25">Buy</button>
                            </div>
                            <div class="shop-item">
                                <div>
                                    <strong>Standard Potion</strong>
                                    <p>Heals 50% HP</p>
                                </div>
                                <button id="buy-potion-50">Buy</button>
                            </div>
                            <div class="shop-item">
                                <div>
                                    <strong>Greater Potion</strong>
                                    <p>Heals 75% HP</p>
                                </div>
                                <button id="buy-potion-75">Buy</button>
                            </div>
                            <div class="shop-item">
                                <div>
                                    <strong>Full Restore</strong>
                                    <p>Heals 100% HP</p>
                                </div>
                                <button id="buy-potion-100">Buy</button>
                            </div>
                            <div class="shop-item">
                                <div>
                                    <strong>2x XP Boost</strong>
                                    <p>Doubles XP gain for the next 100 fights.</p>
                                </div>
                                <button id="buy-xp-boost-2x">Buy</button>
                            </div>
                            <div class="shop-item">
                                <div>
                                    <strong>3x XP Boost</strong>
                                    <p>Triples XP gain for the next 100 fights.</p>
                                </div>
                                <button id="buy-xp-boost-3x">Buy</button>
                            </div>
                        </div>
                    </div>
                    <div id="tab-content-inventory" class="tab-content">
                        <div id="inventory-list"></div>
                        <div class="inventory-actions" style="margin-top: 10px; display: flex; gap: 10px;">
                            <button id="sell-n-btn" class="button-secondary" style="flex: 1;">Sell All N</button>
                            <button id="sell-r-btn" class="button-secondary" style="flex: 1;">Sell All R</button>
                        </div>
                    </div>
                    <div id="tab-content-blacksmith" class="tab-content">
                        <h3>Enhance Equipment</h3>
                        <div id="blacksmith-item-selector">
                            <!-- JS will populate this -->
                        </div>
                        <div id="blacksmith-enhancement-panel" style="display: none;">
                            <div id="enhancement-info">
                                <!-- JS will populate this -->
                            </div>
                            <button id="enhance-item-btn" style="text-align:center;">Enhance</button>
                        </div>
                    </div>
                    <div id="tab-content-rebirth" class="tab-content">
                        <div class="rebirth-points" style="color: var(--rebirth-color); font-weight: bold; font-size: 1.5em; text-align: center; margin-bottom: 15px;">
                            Points: <span id="rebirth-points">0</span></div>
                        <div class="rebirth-stat"><span>ATK Bonus: +<span id="rebirth-atk" class="rebirth-value">0</span></span><button data-rebirth="atk">+</button></div>
                        <div class="rebirth-stat"><span>DEF Bonus: +<span id="rebirth-def" class="rebirth-value">0</span></span><button data-rebirth="def">+</button></div>
                        <div class="rebirth-stat"><span>HP Bonus: +<span id="rebirth-hp" class="rebirth-value">0</span></span><button data-rebirth="hp">+</button></div>
                        <div class="rebirth-stat"><span>Gold Bonus: +<span id="rebirth-gold" class="rebirth-value">0</span>%</span><button data-rebirth="gold">+</button></div>
                        <div class="rebirth-stat"><span>XP Bonus: +<span id="rebirth-xp" class="rebirth-value">0</span>%</span><button data-rebirth="xp">+</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="panel" style="flex-grow: 1; display: flex; flex-direction: column;">
                <div class="tab-buttons">
                    <button class="log-tab-button active" data-log-tab="event">Event Log</button>
                    <button class="log-tab-button" data-log-tab="battle">Battle Log</button>
                </div>
                <div class="panel-body" style="padding: 0; flex-grow: 1; position: relative;">
                    <div id="event-log" class="log-tab-content active activity-log-container" style="border: none; border-radius: 0; height: 100%; width: 100%; position: absolute; top: 0; left: 0;">
                    </div>
                    <div id="battle-log" class="log-tab-content activity-log-container" style="display: none; border: none; border-radius: 0; height: 100%; width: 100%; position: absolute; top: 0; left: 0;">
                    </div>
                </div>
            </div>
        </div>

        <!-- Modals -->
        <div id="class-selection-modal" class="modal">
            <div class="modal-content">
                <h2>Choose Your Class</h2>
                <div class="modal-choices" id="class-selection-choices">
                    <button data-class="Warrior">Warrior</button>
                    <button data-class="Rogue">Rogue</button>
                    <button data-class="Wizard">Wizard</button>
                </div>
                <p id="class-description" class="modal-description">Select a class to learn more.</p>
                <div class="modal-footer-confirm">
                    <button id="confirm-class-btn" disabled>Confirm Selection</button>
                </div>
            </div>
        </div>

        <div id="promotion-modal" class="modal">
            <div class="modal-content">
                <h2 id="promotion-title">Class Promotion!</h2>
                <p id="promotion-text">You have reached a new milestone. Choose your path:</p>
                <div class="modal-choices" id="promotion-choices"></div>
                <p id="promotion-description" class="modal-description">Select a promotion to learn more.</p>
                <div class="modal-footer-confirm">
                    <button id="confirm-promotion-btn" disabled>Confirm Promotion</button>
                </div>
            </div>
        </div>

        <div id="manual-save-modal" class="modal">
            <div class="modal-content">
                <h2>Game Saved!</h2>
                <p>Copy this code and save it somewhere safe. Use the Import Save button to restore your progress.</p>
                <textarea id="manual-save-textarea" readonly></textarea>
                <button id="close-save-modal-btn">Close</button>
            </div>
        </div>

        <!-- Global Tooltip -->
        <div id="global-tooltip"></div>

        <script>
            document.addEventListener('DOMContentLoaded', () => {
                let gameInterval;
                let autoSaveInterval;
                let activeTooltip = {
                    target: null,
                    itemId: null
                };
                const SAVE_KEY = 'idleRpgSaveData_v13_itemStructure';

                const PRIMARY_STAT_POWER_CURVE = 1.08;

                const STAT_NAMES = {
                    str: 'STR', con: 'CON', def: 'DEF', dex: 'DEX',
                    agl: 'AGL', int: 'INT', critChance: 'Crit Chance', critDmg: 'Crit DMG'
                };
                
                const DISPLAY_STATS = {
                    atk: 'ATK', def: 'DEF', hp: 'HP', accuracy: 'Accuracy', evasion: 'Evasion', critChance: 'Crit Chance', critDmg: 'Crit DMG'
                };

                function getDefaultGameState() {
                    return {
                        player: null, currentMonster: null, wave: 1, kills: 0, gold: 0, isRunning: false,
                        potionCosts: { p25: 20, p50: 35, p75: 50, p100: 65 },
                        inventory: [],
                        equipment: { weapon: null, body: null, legs: null },
                        maxInventorySize: 20,
                        rebirth: { points: 0, bonuses: { atk: 0, def: 0, hp: 0, gold: 0, xp: 0 } },
                        activeBoosts: { xp: null },
                        playerTemp: {
                            pointAllocation: { str: 0, con: 0, def: 0, dex: 0, agl: 0, int: 0, critChance: 0, critDmg: 0 },
                            classSelection: null,
                            promotionSelection: null,
                            blacksmithSelection: null,
                            lastEnhancementResult: null,
                            // Buffs and skill trackers
                            standFirmTurns: 0,
                            battleRushTurns: 0,
                            guaranteedCrit: false,
                            guaranteedEvasion: false,
                            attacksSinceLastFocus: 0,
                        }
                    };
                }

                let gameState = getDefaultGameState();

                const classes = {
                    'Warrior': {
                        primaryStat: 'str',
                        description: 'A balanced fighter with high HP and DEF. Excels at sustained combat and survivability.',
                        base: { hp: 120, str: 10, con: 8, def: 6, dex: 3, agl: 2, int: 1, critChance: 0.05, critDmg: 1.5 },
                        growth: { str: 2, con: 2, def: 1, dex: 0.5, agl: 0.5, int: 0, critChance: 0.0005, critDmg: 0 },
                        promotions: { 20: ['Knight', 'Berserker'], 40: { 'Knight': ['Paladin', 'Guardian'], 'Berserker': ['Slayer', 'Warlord'] }, 70: { 'Paladin': ['Holy Knight'], 'Guardian': ['Aegis'], 'Slayer': ['Executioner'], 'Warlord': ['Conqueror'] } }
                    },
                    'Rogue': {
                        primaryStat: 'str',
                        description: 'A swift attacker specializing in high damage and critical hits. Relies on evasion to survive.',
                        base: { hp: 90, str: 12, con: 5, def: 3, dex: 8, agl: 6, int: 1, critChance: 0.10, critDmg: 1.75 },
                        growth: { str: 2, con: 1, def: 0.5, dex: 2, agl: 1, int: 0, critChance: 0.001, critDmg: 0 },
                        promotions: { 20: ['Assassin', 'Ranger'], 40: { 'Assassin': ['Shadow', 'Reaper'], 'Ranger': ['Sharpshooter', 'Pathfinder'] }, 70: { 'Shadow': ['Phantom'], 'Reaper': ['Soul Carver'], 'Sharpshooter': ['Deadeye'], 'Pathfinder': ['Trailblazer'] } }
                    },
                    'Wizard': {
                        primaryStat: 'int',
                        description: 'A master of arcane arts, dealing massive damage with powerful spells. Fragile but deadly.',
                        base: { hp: 80, str: 2, con: 4, def: 2, dex: 6, agl: 3, int: 12, critChance: 0.07, critDmg: 1.6 },
                        growth: { str: 0, con: 1, def: 0.5, dex: 1, agl: 0.5, int: 3, critChance: 0.0007, critDmg: 0 },
                        promotions: { 20: ['Mage', 'Sorcerer'], 40: { 'Mage': ['Archmage', 'Elementalist'], 'Sorcerer': ['Warlock', 'Chronomancer'] }, 70: { 'Archmage': ['Grand Magus'], 'Elementalist': ['Avatar'], 'Warlock': ['Demonologist'], 'Chronomancer': ['Time Lord'] } }
                    },
                };

                const promotionInfo = {
                    'Knight': { description: 'Focuses on defense, becoming a stalwart protector who can withstand heavy blows.' },
                    'Berserker': { description: 'An offensive powerhouse who deals more damage by embracing risk and critical strikes.' },
                    'Paladin': { description: 'A holy warrior who blends offense and defense with sacred power.' },
                    'Guardian': { description: 'The ultimate shield, possessing unmatched defensive capabilities.' },
                    'Slayer': { description: 'A ruthless killer focused on executing single targets with overwhelming force.' },
                    'Warlord': { description: 'A charismatic leader in battle, bolstering their own power while commanding the field.' },
                    'Assassin': { description: 'A master of burst damage and criticals, eliminating foes with deadly precision.' },
                    'Ranger': { description: 'A nimble archer who excels at consistent damage and avoiding attacks.' },
                    'Shadow': { description: 'Uses stealth and deception to strike from the darkness, ensuring a fatal blow.' },
                    'Reaper': { description: 'A fearsome combatant who seems to dance with death, growing stronger with every kill.' },
                    'Sharpshooter': { description: 'An unrivaled marksman whose precision leads to devastating critical hits.' },
                    'Pathfinder': { description: 'A resourceful survivor who adapts to any situation, moving with incredible speed.' },
                    'Mage': { description: 'A student of pure magic, wielding raw arcane power to demolish enemies.' },
                    'Sorcerer': { description: 'A natural talent who bends magic to their will, often with unpredictable and chaotic results.' },
                    'Archmage': { description: 'A supreme spellcaster who has achieved mastery over all forms of arcane magic.' },
                    'Elementalist': { description: 'Commands the primal forces of fire, ice, and lightning to annihilate foes.' },
                    'Warlock': { description: 'Draws upon forbidden, dark powers, sacrificing vitality for immense destructive force.' },
                    'Chronomancer': { description: 'Manipulates time itself, slowing enemies and hastening their own actions.' },
                };

                const promotionGrowthAdjustments = {
                    'Knight': { con: 1, def: 1, str: -1 }, 'Berserker': { str: 1, critChance: 0.001, con: -1 },
                    'Assassin': { str: 1, dex: 1, agl: 1, critChance: 0.0005, con: -1 }, 'Ranger': { dex: 1, agl: 1, str: 0, con: -1 },
                    'Mage': { int: 1, str: 1, dex: -1 }, 'Sorcerer': { int: 1, dex: 1, str: -1 }
                };


                const promotionSkills = {
                    // Warrior Path
                    'Knight': { name: 'Aegis Block', description: '15% chance to block all incoming damage.' },
                    'Paladin': { name: 'Holy Shield', description: 'Aegis Block now also heals you for 5% of your Max HP.' },
                    'Holy Knight': { name: 'Divine Retribution', description: 'Holy Shield now also retaliates for 100% of your DEF as Holy damage.' },
                    'Guardian': { name: 'Stand Firm', description: 'Aegis Block now also grants +30% DEF for 3 seconds.' },
                    'Aegis': { name: 'Thornmail', description: 'Stand Firm now also reflects 20% of pre-mitigation damage back to the attacker.' },
                    'Berserker': { name: 'Frenzy', description: 'Gain +8% ATK for every 10% of missing health.' },
                    'Slayer': { name: 'Execute', description: 'Attacks against enemies below 20% HP deal 50% more damage.' },
                    'Executioner': { name: 'Cull the Weak', description: 'Execute threshold increased to 30% HP and bonus damage increased to 100%.' },
                    'Warlord': { name: 'Battle Rush', description: 'Attacks have a 20% chance to grant +20% ATK for 3 seconds.' },
                    'Conqueror': { name: 'Unyielding Assault', description: 'Battle Rush now also grants 10% Lifesteal.' },
                    // Rogue Path
                    'Assassin': { name: 'Bleed', description: 'Critical hits cause the enemy to bleed for 30% of your ATK each second for 3 seconds.' },
                    'Shadow': { name: 'Shadow Step', description: 'Attacks have a 10% chance to grant a guaranteed critical hit on your next attack.' },
                    'Phantom': { name: 'Invisibility', description: 'Shadow Step now grants a guaranteed crit and 100% evasion for your next attack.' },
                    'Reaper': { name: 'Hemorrhage', description: 'Bleed can now stack up to 3 times.' },
                    'Soul Carver': { name: 'Exsanguinate', description: 'Bleed damage ticks can now critically strike.' },
                    'Ranger': { name: 'Double Shot', description: '15% chance to attack a second time for 60% damage.' },
                    'Sharpshooter': { name: 'Focus', description: 'Every 5th attack is a guaranteed critical hit.' },
                    'Deadeye': { name: 'Lethal Precision', description: 'Guaranteed criticals from Focus deal +50% critical damage.' },
                    'Pathfinder': { name: 'Sunder', description: 'Attacks have a 25% chance to reduce enemy DEF by 10% for 5 seconds.' },
                    'Trailblazer': { name: 'Armor Shatter', description: 'Sunder now stacks up to 3 times and also reduces enemy ATK by 5%.' },
                    // Wizard Path
                    'Mage': { name: 'Arcane Power', description: 'Attacks have a 10% chance to unleash a spell for 250% of your ATK as bonus damage.' },
                    'Archmage': { name: 'High Voltage', description: 'Arcane Power proc chance increased to 15% and damage to 300%.' },
                    'Grand Magus': { name: 'Chain Lightning', description: 'Arcane Power hits now explode, dealing an additional 150% ATK damage.' },
                    'Elementalist': { name: 'Combustion', description: 'Arcane Power now also applies a burn for 50% of your ATK for 3 seconds.' },
                    'Avatar': { name: 'Apocalypse', description: 'Combustion burn damage is increased to 100% ATK and also reduces enemy DEF by 15%.' },
                    'Sorcerer': { name: 'Soul Drain', description: 'Attacks have a 5% chance to deal 150% damage and heal you for 50% of the damage dealt.' },
                    'Warlock': { name: 'Devour Soul', description: 'Soul Drain proc chance increased to 8% and heal increased to 75%.' },
                    'Demonologist': { name: 'Annihilate', description: 'Devour Soul now deals bonus damage equal to 5% of the monster\'s max HP.' },
                    'Chronomancer': { name: 'Time Warp', description: 'Soul Drain now also has a 50% chance to make the monster miss its next attack.' },
                    'Time Lord': { name: 'Paradox', description: 'Time Warp now always makes the monster miss its next attack.' }
                };

                const monsters = {
                    regular: [
                        { name: 'Slime', baseHp: 30, baseAtk: 5, baseDef: 2, baseEvasion: 0.01, gold: 5, xp: 5, dropChance: 0.15, monsterType: 'regular' },
                        { name: 'Giant Rat', baseHp: 25, baseAtk: 6, baseDef: 1, baseEvasion: 0.03, gold: 4, xp: 4, dropChance: 0.10, monsterType: 'regular' },
                        { name: 'Goblin Scout', baseHp: 40, baseAtk: 7, baseDef: 3, baseEvasion: 0.05, gold: 7, xp: 6, dropChance: 0.20, monsterType: 'regular' },
                        { name: 'Cave Bat', baseHp: 20, baseAtk: 8, baseDef: 0, baseEvasion: 0.08, gold: 3, xp: 3, dropChance: 0.08, monsterType: 'regular' },
                        { name: 'Kobold Miner', baseHp: 35, baseAtk: 9, baseDef: 2, baseEvasion: 0.02, gold: 8, xp: 7, dropChance: 0.18, monsterType: 'regular' },
                        { name: 'Forest Spider', baseHp: 30, baseAtk: 7, baseDef: 1, baseEvasion: 0.10, gold: 6, xp: 5, dropChance: 0.12, monsterType: 'regular' },
                        { name: 'Undead Soldier', baseHp: 50, baseAtk: 6, baseDef: 5, baseEvasion: 0.01, gold: 9, xp: 8, dropChance: 0.22, monsterType: 'regular' },
                    ],
                    mutant: [
                        { name: 'Mutated Slime', baseHp: 80, baseAtk: 10, baseDef: 1, baseEvasion: 0.01, gold: 20, xp: 15, dropChance: 0.50, monsterType: 'mutant' },
                        { name: 'Rabid Wolf', baseHp: 50, baseAtk: 18, baseDef: 2, baseEvasion: 0.12, gold: 25, xp: 18, dropChance: 0.40, monsterType: 'mutant' },
                        { name: 'Shrieking Fungus', baseHp: 100, baseAtk: 8, baseDef: 8, baseEvasion: 0.00, gold: 30, xp: 20, dropChance: 0.60, monsterType: 'mutant' },
                    ],
                    elite: [
                        { name: 'Orc Grunt', baseHp: 120, baseAtk: 20, baseDef: 8, baseEvasion: 0.05, gold: 50, xp: 30, dropChance: 0.8, monsterType: 'elite' },
                        { name: 'Troll', baseHp: 150, baseAtk: 18, baseDef: 12, baseEvasion: 0.02, gold: 65, xp: 40, dropChance: 0.9, monsterType: 'elite' },
                        { name: 'Ogre Mage', baseHp: 100, baseAtk: 28, baseDef: 6, baseEvasion: 0.04, gold: 80, xp: 50, dropChance: 0.85, monsterType: 'elite' },
                        { name: 'Goblin Shaman', baseHp: 90, baseAtk: 32, baseDef: 5, baseEvasion: 0.08, gold: 90, xp: 55, dropChance: 0.88, monsterType: 'elite' },
                        { name: 'Stone Golem', baseHp: 200, baseAtk: 15, baseDef: 20, baseEvasion: 0.00, gold: 100, xp: 60, dropChance: 1.0, monsterType: 'elite' },
                    ],
                    bosses: [
                        { name: 'Grimgnaw the Goblin King', baseHp: 400, baseAtk: 35, baseDef: 15, baseEvasion: 0.06, gold: 400, xp: 200, dropChance: 1.0, monsterType: 'boss' },
                        { name: 'The Slime Mother', baseHp: 600, baseAtk: 30, baseDef: 25, baseEvasion: 0.03, gold: 600, xp: 350, dropChance: 1.0, monsterType: 'boss' },
                        { name: 'Hydra', baseHp: 500, baseAtk: 45, baseDef: 12, baseEvasion: 0.10, gold: 800, xp: 500, dropChance: 1.0, monsterType: 'boss' },
                        { name: 'Dragon Whelp', baseHp: 700, baseAtk: 40, baseDef: 20, baseEvasion: 0.08, gold: 1000, xp: 600, dropChance: 1.0, monsterType: 'boss' },
                    ]
                };
                const itemData = {
                    types: ['weapon', 'body', 'legs'],
                    rarities: {
                        N:   { color: '#DEDEDE',  statMod: 1.0, value: 2,   baseStatCount: 1, bonusStats: 0, enhanceCostMod: 1.0 },
                        R:   { color: '#63C270',  statMod: 1.2, value: 8,   baseStatCount: 2, bonusStats: 1, enhanceCostMod: 1.5 },
                        SR:  { color: '#6386C2',  statMod: 1.5, value: 40,  baseStatCount: 3, bonusStats: 2, enhanceCostMod: 2.5 },
                        SSR: { color: '#9663C2',  statMod: 2.0, value: 200, baseStatCount: 4, bonusStats: 3, enhanceCostMod: 5.0 },
                        UR:  { color: '#C29463',  statMod: 2.8, value: 1000,baseStatCount: 4, bonusStats: 4, enhanceCostMod: 10.0 },
                        LR:  { color: '#FFD700',  statMod: 3.5, value: 5000,baseStatCount: 5, bonusStats: 4, enhanceCostMod: 25.0 },
                    },
                    bonusStatPool: Object.keys(STAT_NAMES),
                    names: {
                        weapon: {
                            Warrior: ['Sword', 'Axe', 'Gauntlet'],
                            Rogue: ['Dagger', 'Bow', 'Claw'],
                            Wizard: ['Staff', 'Wand', 'Rod']
                        },
                        body: {
                            Warrior: ['Armor', 'Vest'],
                            Rogue: ['Leather', 'Jacket'],
                            Wizard: ['Robe', 'Cape']
                        },
                        legs: {
                            Warrior: ['Greaves', 'Sabatons'],
                            Rogue: ['Boots', 'Slippers'],
                            Wizard: ['Shoes', 'Wraps']
                        },
                        prefixes: {
                            Warrior: ['Mighty', 'Stalwart', 'Brutal', 'Savage', 'Guardian\'s'],
                            Rogue: ['Swift', 'Silent', 'Vicious', 'Shadow', 'Assassin\'s'],
                            Wizard: ['Arcane', 'Mystic', 'Elemental', 'Warlock\'s', 'Sage\'s'],
                            Balanced: ['Fine', 'Superior', 'Masterwork', 'Exquisite', 'Perfect']
                        }
                    }
                };

                const itemSets = {
                    "Stonewall Plate": {
                        class: "Warrior",
                        items: ["Stonewall Greathelm", "Stonewall Chestplate", "Stonewall Greaves"],
                        bonuses: {
                            2: { def: 30, description: "2pc: +30 DEF" },
                            3: { hpPercent: 0.15, description: "3pc: +15% Max HP" }
                        }
                    },
                    "Undead King's Regalia": {
                        class: "Rogue",
                        items: ["Undead King's Dagger", "Undead King's Robe", "Undead King's Slippers"],
                        bonuses: {
                            2: { agl: 20, description: "2pc: +20 AGL" },
                            3: { critDmg: 0.25, description: "3pc: +25% Crit Damage" }
                        }
                    },
                    "Archon's Raiment": {
                        class: "Wizard",
                        items: ["Archon's Crown", "Archon's Mantle", "Archon's Treads"],
                        bonuses: {
                            2: { int: 25, description: "2pc: +25 INT" },
                            3: { critChance: 0.05, description: "3pc: +5% Crit Chance" }
                        }
                    }
                };

                const UIElements = {
                    playerName: document.getElementById('player-name'), playerClass: document.getElementById('player-class'),
                    playerLevel: document.getElementById('player-level'), playerStatPoints: document.getElementById('player-stat-points'),
                    playerHpText: document.getElementById('player-hp-text'), playerHpFill: document.getElementById('player-hp-fill'),
                    playerXpText: document.getElementById('player-xp-text'), playerXpFill: document.getElementById('player-xp-fill'),
                    playerAtk: document.getElementById('player-atk'), playerDef: document.getElementById('player-def'),
                    playerCritChance: document.getElementById('player-crit-chance'), playerCritDmg: document.getElementById('player-crit-dmg'),
                    playerEvasion: document.getElementById('player-evasion'), playerAccuracy: document.getElementById('player-accuracy'),
                    playerGold: document.getElementById('player-gold'), monsterName: document.getElementById('monster-name'),
                    monsterHpText: document.getElementById('monster-hp-text'), monsterHpFill: document.getElementById('monster-hp-fill'),
                    waveCounter: document.getElementById('wave-counter'), killCounter: document.getElementById('kill-counter'), 
                    eventLog: document.getElementById('event-log'), battleLog: document.getElementById('battle-log'),
                    challengeBossBtn: document.getElementById('challenge-boss-btn'),
                    classSelectionModal: document.getElementById('class-selection-modal'), promotionModal: document.getElementById('promotion-modal'),
                    classSelectionChoices: document.getElementById('class-selection-choices'),
                    promotionChoices: document.getElementById('promotion-choices'),
                    classDescription: document.getElementById('class-description'), promotionDescription: document.getElementById('promotion-description'),
                    confirmClassBtn: document.getElementById('confirm-class-btn'),
                    confirmPromotionBtn: document.getElementById('confirm-promotion-btn'),
                    inventoryList: document.getElementById('inventory-list'), equipmentDisplay: document.getElementById('equipment-display'),
                    newGameBtn: document.getElementById('new-game-btn'), rebirthBtn: document.getElementById('rebirth-btn'),
                    manualSaveBtn: document.getElementById('manual-save-btn'), manualLoadBtn: document.getElementById('manual-load-btn'),
                    manualSaveModal: document.getElementById('manual-save-modal'), manualSaveTextarea: document.getElementById('manual-save-textarea'),
                    closeSaveModalBtn: document.getElementById('close-save-modal-btn'),
                    sellNBtn: document.getElementById('sell-n-btn'), sellRBtn: document.getElementById('sell-r-btn'),
                    rebirthPoints: document.getElementById('rebirth-points'), rebirthAtk: document.getElementById('rebirth-atk'),
                    rebirthDef: document.getElementById('rebirth-def'), rebirthHp: document.getElementById('rebirth-hp'),
                    rebirthGold: document.getElementById('rebirth-gold'), rebirthXp: document.getElementById('rebirth-xp'),
                    globalTooltip: document.getElementById('global-tooltip'),
                    skillPanel: document.getElementById('skill-panel'), skillDisplay: document.getElementById('skill-display'),
                    pointInvestmentDisplay: document.getElementById('point-investment-display'),
                    confirmInvestBtn: document.getElementById('confirm-invest-btn'),
                    resetInvestBtn: document.getElementById('reset-invest-btn'),
                    buyPotion25: document.getElementById('buy-potion-25'), buyPotion50: document.getElementById('buy-potion-50'),
                    buyPotion75: document.getElementById('buy-potion-75'), buyPotion100: document.getElementById('buy-potion-100'),
                    buyXpBoost2x: document.getElementById('buy-xp-boost-2x'), buyXpBoost3x: document.getElementById('buy-xp-boost-3x'),
                    xpBoostStatus: document.getElementById('xp-boost-status'),
                    blacksmithItemSelector: document.getElementById('blacksmith-item-selector'),
                    blacksmithEnhancementPanel: document.getElementById('blacksmith-enhancement-panel'),
                    enhancementInfo: document.getElementById('enhancement-info'),
                    enhanceItemBtn: document.getElementById('enhance-item-btn'),
                };

                function startGame() {
                    if (gameInterval) clearInterval(gameInterval);
                    if (autoSaveInterval) clearInterval(autoSaveInterval);

                    gameState.isRunning = true;
                    if (!gameState.currentMonster) spawnMonster();

                    updateAllUIs();
                    gameInterval = setInterval(gameLoop, 1000);
                    autoSaveInterval = setInterval(autoSaveToLocalStorage, 15000);
                }

                function autoSaveToLocalStorage() {
                    if (!gameState.player || !gameState.isRunning) return;
                    try {
                        const stateToSave = { ...gameState };
                        delete stateToSave.playerTemp; // Don't save transient data
                        const gameStateString = JSON.stringify(stateToSave);
                        localStorage.setItem(SAVE_KEY, gameStateString);
                    } catch (e) {
                        console.error("Auto-save failed:", e);
                        logAction("Auto-save failed. Use Export Save as a backup.", "log-error", "event");
                    }
                }

                function migrateSaveData(loadedState) {
                    if (loadedState.inventory && Array.isArray(loadedState.inventory)) {
                        loadedState.inventory.forEach(item => {
                            if (item) {
                                if (item.enhancementLevel === undefined) item.enhancementLevel = 0;
                                if (item.bonusStats === undefined) item.bonusStats = {};
                                if (item.enhancementBonusStats === undefined) item.enhancementBonusStats = {};
                                if (item.enhancementProgress) delete item.enhancementProgress; // Remove obsolete property
                                
                                for (const statName in STAT_NAMES) {
                                    if (item.enhancementBonusStats[statName] === undefined) {
                                        item.enhancementBonusStats[statName] = 0;
                                    }
                                }
                            }
                        });
                    }

                    if (loadedState.player) {
                        if (loadedState.player.promotionPending === undefined) {
                            loadedState.player.promotionPending = false;
                        }
                        if (loadedState.player.pendingPromotionChoices === undefined) {
                             loadedState.player.pendingPromotionChoices = null;
                        }
                        if (loadedState.player.activeSkills === undefined) {
                            loadedState.player.activeSkills = [];
                        }
                    }
                    
                    return loadedState;
                }

                function loadFromLocalStorage() {
                    try {
                        const savedState = localStorage.getItem(SAVE_KEY);
                        if (savedState) {
                            let loadedState = JSON.parse(savedState);
                            if (!loadedState.player || !loadedState.player.baseStats) throw new Error("Invalid save.");
                            
                            loadedState = migrateSaveData(loadedState);

                            gameState = deepMerge(getDefaultGameState(), loadedState);
                            resetTransientData();
                            logAction("Game loaded automatically.", 'log-system', "event");
                            return true;
                        }
                    } catch (e) {
                        console.error("Failed to load from localStorage:", e);
                        logAction('Could not auto-load game. Starting new game.', 'log-error', "event");
                        localStorage.removeItem(SAVE_KEY);
                    }
                    return false;
                }

                function manualSave() {
                    if (!gameState.player) return;
                    try {
                        const stateToSave = { ...gameState };
                        delete stateToSave.playerTemp;
                        const encodedSave = btoa(JSON.stringify(stateToSave));
                        UIElements.manualSaveTextarea.value = encodedSave;
                        UIElements.manualSaveModal.style.display = 'flex';
                        UIElements.manualSaveTextarea.select();
                        logAction("Exported save state.", 'log-system', "event");
                    } catch (e) {
                        console.error("Manual save failed:", e);
                        logAction('EXPORT FAILED.', 'log-error', "event");
                    }
                }

                function manualLoad() {
                    const encodedSave = prompt("Please paste your save code:");
                    if (!encodedSave) return;
                    try {
                        let loadedState = JSON.parse(atob(encodedSave));
                        if (!loadedState.player || !loadedState.player.baseStats) throw new Error("Invalid save.");

                        loadedState = migrateSaveData(loadedState);

                        clearInterval(gameInterval); clearInterval(autoSaveInterval);
                        gameState = deepMerge(getDefaultGameState(), loadedState);
                        resetTransientData();
                        logAction("Game imported successfully.", 'log-system', "event");
                        UIElements.classSelectionModal.style.display = 'none';
                        startGame();
                        checkForPendingActions();
                    } catch (e) {
                        console.error("Manual load failed:", e);
                        logAction('IMPORT FAILED: Invalid save code.', 'log-error', "event");
                    }
                }

                function initializeGame() {
                    setupTabs();
                    setupLogTabs();
                    setupClassSelectionEvents();
                    if (loadFromLocalStorage()) {
                        UIElements.classSelectionModal.style.display = 'none';
                        startGame();
                        checkForPendingActions();
                    } else {
                        logAction("Welcome to Idle RPG. Select your class to begin.", 'log-system', "event");
                        UIElements.classSelectionModal.style.display = 'flex';
                    }
                }

                function checkForPendingActions() {
                    if (gameState.player && gameState.player.promotionPending && gameState.player.pendingPromotionChoices) {
                        logAction("Promotion choice is pending. Please select your new class.", "log-system", "event");
                        showPromotionModal(gameState.player.pendingPromotionChoices);
                    } else if (gameState.player) {
                        const availablePromotion = getAvailablePromotion(gameState.player);
                        if (availablePromotion) {
                             gameState.player.promotionPending = true;
                             gameState.player.pendingPromotionChoices = availablePromotion.choices;
                             showPromotionModal(availablePromotion.choices);
                        }
                    }
                }

                function selectClass(className) {
                    const classInfo = classes[className];
                    gameState.player = {
                        name: 'Player-' + Math.floor(1000 + Math.random() * 9000),
                        className: className, baseClassName: className,
                        level: 1, xp: 0, xpToNextLevel: 40,
                        statPoints: 5,
                        baseStats: { ...classInfo.base },
                        investedStats: { str: 0, con: 0, def: 0, dex: 0, agl: 0, int: 0, critChance: 0, critDmg: 0 },
                        currentHp: classInfo.base.hp, activeSkills: [],
                        promotionPending: false,
                        pendingPromotionChoices: null,
                    };
                    resetTransientData();
                    UIElements.classSelectionModal.style.display = 'none';
                    logAction(`You have chosen the path of the ${className}.`, 'log-system', "event");
                    startGame();
                }
                
                function getPlayerTotalStats(hypotheticalItem = null) {
                    if (!gameState.player) return {};
                    const p = gameState.player;
                    const rawStats = {};

                    for (const statName in STAT_NAMES) {
                        rawStats[statName] = 0;
                    }

                    for (const statName in rawStats) {
                        rawStats[statName] += p.baseStats[statName] || 0;
                        if (p.investedStats[statName]) {
                            if (statName === 'critChance') rawStats[statName] += p.investedStats[statName] * 0.002;
                            else if (statName === 'critDmg') rawStats[statName] += p.investedStats[statName] * 0.005;
                            else rawStats[statName] += p.investedStats[statName];
                        }
                    }

                    const equippedSets = {};
                    const effectiveEquipment = { ...gameState.equipment };
                    if (hypotheticalItem) {
                        effectiveEquipment[hypotheticalItem.type] = hypotheticalItem; 
                    }

                    for (const type in effectiveEquipment) {
                        let item = effectiveEquipment[type];
                        if (typeof item === 'number') {
                            item = gameState.inventory.find(i => i.id === item);
                        }

                        if (item) {
                            if (item.setName) {
                                equippedSets[item.setName] = (equippedSets[item.setName] || 0) + 1;
                            }
                            for (const stat in item) {
                                if (STAT_NAMES[stat] && typeof item[stat] === 'number') {
                                    rawStats[stat] += item[stat];
                                }
                            }
                            for (const stat in (item.bonusStats || {})) {
                                if (rawStats[stat] !== undefined) {
                                    rawStats[stat] += item.bonusStats[stat];
                                }
                            }
                            for (const stat in (item.enhancementBonusStats || {})) {
                                if (rawStats[stat] !== undefined) {
                                    rawStats[stat] += item.enhancementBonusStats[stat];
                                }
                            }
                        }
                    }

                    let hpPercentBonus = 0;
                    for (const setName in equippedSets) {
                        const setInfo = itemSets[setName];
                        const count = equippedSets[setName];
                        for (let i = 2; i <= count; i++) {
                            if (setInfo.bonuses[i]) {
                                for (const bonusStat in setInfo.bonuses[i]) {
                                    if (bonusStat === 'description') continue;
                                    if (bonusStat === 'hpPercent') {
                                        hpPercentBonus += setInfo.bonuses[i][bonusStat];
                                    } else if (rawStats[bonusStat] !== undefined) {
                                        rawStats[bonusStat] += setInfo.bonuses[i][bonusStat];
                                    }
                                }
                            }
                        }
                    }
                    
                    const finalStats = { ...rawStats };
                    const primaryStat = classes[p.baseClassName].primaryStat;

                    finalStats.atk = Math.pow(rawStats[primaryStat] || 1, PRIMARY_STAT_POWER_CURVE) + (gameState.rebirth.bonuses.atk || 0);
                    finalStats.def = (rawStats.def || 0) + (gameState.rebirth.bonuses.def || 0);
                    finalStats.hp = 50 + ((rawStats.con || 0) * 5) + (gameState.rebirth.bonuses.hp || 0);
                    finalStats.accuracy = (rawStats.dex || 0) * 0.002;
                    finalStats.evasion = (rawStats.agl || 0) * 0.001;

                    if (hpPercentBonus > 0) {
                        finalStats.hp *= (1 + hpPercentBonus);
                    }

                    // SKILL MODS
                    if (p.activeSkills.includes('Frenzy') && !hypotheticalItem) {
                        const missingHpPercent = 1 - (p.currentHp / finalStats.hp);
                        const frenzyBonus = Math.floor(missingHpPercent / 0.1) * 0.08;
                        finalStats.atk *= (1 + frenzyBonus);
                    }
                    if (gameState.playerTemp.standFirmTurns > 0 && !hypotheticalItem) {
                        finalStats.def *= 1.30;
                    }
                    if (gameState.playerTemp.battleRushTurns > 0 && !hypotheticalItem) {
                        finalStats.atk *= 1.20;
                    }


                    if (p.currentHp > finalStats.hp && !hypotheticalItem) {
                        p.currentHp = finalStats.hp;
                    }
                    
                    return finalStats;
                }

                function gameLoop() {
                    if (!gameState.isRunning || !gameState.player || !gameState.currentMonster) return;
                    const player = gameState.player;
                    
                    handleBuffsAndDebuffs();

                    if (gameState.currentMonster.hp <= 0) { monsterDefeated(); return; }

                    const playerStats = getPlayerTotalStats();
                    let playerDamage = calculateDamage(playerStats, gameState.currentMonster, true);
                    gameState.currentMonster.hp -= playerDamage.damage;
                    logAction(`You hit ${gameState.currentMonster.name} for ${playerDamage.damage} damage.${playerDamage.isCrit ? ' (CRIT!)' : ''}`, 'log-player', 'battle');
                    
                    handlePostPlayerAttackSkills(playerStats, playerDamage);

                    if (gameState.currentMonster.hp <= 0) { monsterDefeated(); return; }
                    
                    if (gameState.currentMonster.missNextAttack) {
                        logAction(`${gameState.currentMonster.name}'s attack was nullified by a time distortion!`, 'log-skill', 'battle');
                        gameState.currentMonster.missNextAttack = false;
                    } else if (gameState.playerTemp.guaranteedEvasion) {
                        logAction(`You phase through the attack, taking no damage!`, 'log-skill', 'battle');
                        gameState.playerTemp.guaranteedEvasion = false;
                    } else {
                        let monsterDamage = calculateDamage(gameState.currentMonster, playerStats, false);
                        
                        let wasBlocked = false;
                        if(player.activeSkills.includes('Aegis Block') && Math.random() < 0.15) {
                            wasBlocked = true;
                            if(player.activeSkills.includes('Holy Shield')) {
                                const healAmount = Math.round(playerStats.hp * 0.05);
                                player.currentHp = Math.min(playerStats.hp, player.currentHp + healAmount);
                                logAction(`You blocked the attack with your Holy Shield, healing for ${healAmount} HP!`, 'log-skill', 'battle');
                            } else {
                                logAction(`You blocked the attack with Aegis Block!`, 'log-skill', 'battle');
                            }

                            if(player.activeSkills.includes('Stand Firm')) {
                                gameState.playerTemp.standFirmTurns = 3;
                                logAction(`You Stand Firm, bolstering your defense!`, 'log-skill', 'battle');
                            }
                            if(player.activeSkills.includes('Divine Retribution')) {
                                const retaliateDmg = Math.round(playerStats.def);
                                gameState.currentMonster.hp -= retaliateDmg;
                                logAction(`Your shield erupts with holy light, dealing ${retaliateDmg} damage!`, 'log-skill', 'battle');
                            }
                            monsterDamage.damage = 0;
                        }

                        if (player.activeSkills.includes('Thornmail') && gameState.playerTemp.standFirmTurns > 0 && !wasBlocked) {
                            const reflectDmg = Math.round(monsterDamage.preMitigationDamage * 0.20);
                            gameState.currentMonster.hp -= reflectDmg;
                            logAction(`Your Thornmail reflects ${reflectDmg} damage!`, 'log-skill', 'battle');
                        }

                        gameState.player.currentHp -= monsterDamage.damage;
                        logAction(`${gameState.currentMonster.name} hits you for ${monsterDamage.damage} damage.`, 'log-monster', 'battle');
                    }

                    if (gameState.player.currentHp <= 0) playerDefeated();
                    updateAllUIs();
                }

                function calculateDamage(attacker, defender, isPlayerAttacker) {
                    const p = gameState.player;
                    const monster = gameState.currentMonster;
                    
                    // --- HIT CHANCE CLAMPING ---
                    const MIN_HIT_CHANCE = 0.25; // 25% minimum chance to hit
                    const MAX_HIT_CHANCE = 0.95; // 95% maximum chance to hit

                    const defenderEvasion = isPlayerAttacker ? (monster.evasion || 0) : (defender.evasion || 0);
                    const attackerAccuracy = attacker.accuracy || 0;

                    let hitChance = 0.90 + attackerAccuracy - defenderEvasion;
                    hitChance = Math.max(MIN_HIT_CHANCE, Math.min(MAX_HIT_CHANCE, hitChance));

                    if (Math.random() > hitChance) {
                        logAction(`${isPlayerAttacker ? 'Your' : (attacker.name + "'s")} attack was evaded!`, 'log-system', 'battle');
                        return { damage: 0, isCrit: false, preMitigationDamage: 0 };
                    }
                    // --- END HIT CHANCE ---

                    let isCrit = false;
                    if (isPlayerAttacker) {
                        gameState.playerTemp.attacksSinceLastFocus++;
                        if (p.activeSkills.includes('Focus') && gameState.playerTemp.attacksSinceLastFocus >= 5) {
                             isCrit = true;
                             gameState.playerTemp.attacksSinceLastFocus = 0;
                             logAction('Focus guarantees a critical hit!', 'log-skill', 'battle');
                        } else if (gameState.playerTemp.guaranteedCrit) {
                            isCrit = true;
                            gameState.playerTemp.guaranteedCrit = false;
                            logAction('Shadow Step guarantees a critical hit!', 'log-skill', 'battle');
                        }
                    }
                    if(!isCrit) isCrit = Math.random() < (attacker.critChance || 0);

                    let critMultiplier = isCrit ? (attacker.critDmg || 1.5) : 1;
                    if (isCrit && isPlayerAttacker && p.activeSkills.includes('Lethal Precision') && gameState.playerTemp.attacksSinceLastFocus === 0) {
                        critMultiplier += 0.5;
                    }

                    let baseDamage = (attacker.atk || 0);
                    
                    let defenderDef = isPlayerAttacker ? (monster.def || 0) : (defender.def || 0);
                    if (isPlayerAttacker && monster.debuffs['Sunder']) {
                        defenderDef *= (1 - (monster.debuffs['Sunder'].stacks * 0.1));
                    }
                     if (isPlayerAttacker && monster.debuffs['Apocalypse']) {
                        defenderDef *= (1 - 0.15);
                    }

                    let damageMultiplier = 1.0;
                    if (isPlayerAttacker) {
                        let executeThreshold = 0.2;
                        let executeBonus = 0.5;
                        if (p.activeSkills.includes('Cull the Weak')) {
                            executeThreshold = 0.3;
                            executeBonus = 1.0;
                        }
                        if (p.activeSkills.includes('Execute') && monster.hp / monster.maxHp <= executeThreshold) {
                            damageMultiplier += executeBonus;
                        }
                    }
                    
                    const preMitigationDamage = baseDamage * critMultiplier * damageMultiplier;
                    const damageReduction = 1 - (defenderDef / (defenderDef + 100));
                    let finalDamage = Math.round(preMitigationDamage * damageReduction);

                    return { damage: Math.max(1, finalDamage), isCrit: isCrit, preMitigationDamage: preMitigationDamage };
                }

                function handlePostPlayerAttackSkills(playerStats, playerDamage) {
                    const p = gameState.player;
                    const monster = gameState.currentMonster;
                    
                    // Lifesteal
                    if (p.activeSkills.includes('Unyielding Assault') && gameState.playerTemp.battleRushTurns > 0) {
                        const lifestealAmount = Math.round(playerDamage.damage * 0.10);
                        p.currentHp = Math.min(playerStats.hp, p.currentHp + lifestealAmount);
                        logAction(`Unyielding Assault heals you for ${lifestealAmount} HP.`, 'log-skill', 'battle');
                    }

                    // Chance-based procs
                    if (p.activeSkills.includes('Double Shot') && Math.random() < 0.15) {
                        const secondShotDmg = Math.round(playerDamage.damage * 0.6);
                        monster.hp -= secondShotDmg;
                        logAction(`Double Shot hits for an extra ${secondShotDmg} damage!`, 'log-skill', 'battle');
                    }
                    if (p.activeSkills.includes('Shadow Step') && Math.random() < 0.1) {
                        gameState.playerTemp.guaranteedCrit = true;
                        if (p.activeSkills.includes('Invisibility')) {
                            gameState.playerTemp.guaranteedEvasion = true;
                        }
                    }
                    if (p.activeSkills.includes('Battle Rush') && Math.random() < 0.2) {
                        gameState.playerTemp.battleRushTurns = 3;
                        logAction('Battle Rush grants you a surge of power!', 'log-skill', 'battle');
                    }

                    // Debuff applications
                    if (playerDamage.isCrit && p.activeSkills.includes('Bleed')) {
                        const maxStacks = p.activeSkills.includes('Hemorrhage') ? 3 : 1;
                        let logMsg;
                        
                        if (!monster.debuffs['Bleed']) {
                            monster.debuffs['Bleed'] = { damage: Math.round(playerStats.atk * 0.3), duration: 3, stacks: 1 };
                            logMsg = 'Your critical hit causes the enemy to Bleed!';
                        } else {
                            monster.debuffs['Bleed'].duration = 3; // ALWAYS refresh duration
                            if (monster.debuffs['Bleed'].stacks < maxStacks) {
                                monster.debuffs['Bleed'].stacks++;
                                logMsg = 'Your critical hit adds a stack and refreshes Bleed!';
                            } else {
                                logMsg = 'Your critical hit refreshes Bleed!';
                            }
                        }
                        logAction(logMsg, 'log-skill', 'battle');
                    }

                    if (p.activeSkills.includes('Sunder') && Math.random() < 0.25) {
                        const maxStacks = p.activeSkills.includes('Armor Shatter') ? 3 : 1;
                        if (!monster.debuffs['Sunder']) {
                            monster.debuffs['Sunder'] = { duration: 5, stacks: 1 };
                            logAction('You Sunder the enemy\'s armor!', 'log-skill', 'battle');
                        } else if (monster.debuffs['Sunder'].stacks < maxStacks) {
                            monster.debuffs['Sunder'].stacks++;
                            monster.debuffs['Sunder'].duration = 5;
                            logAction('You apply another stack of Sunder!', 'log-skill', 'battle');
                        } else {
                            monster.debuffs['Sunder'].duration = 5; // Refresh
                        }
                    }

                    // Wizard skills
                    let arcanePowerProc = false;
                    let arcanePowerChance = 0;
                    if(p.activeSkills.includes('High Voltage')) arcanePowerChance = 0.15;
                    else if (p.activeSkills.includes('Arcane Power')) arcanePowerChance = 0.10;
                    
                    if (arcanePowerChance > 0 && Math.random() < arcanePowerChance) {
                        arcanePowerProc = true;
                        let arcaneDmg = playerStats.atk * (p.activeSkills.includes('High Voltage') ? 3.0 : 2.5);
                        if (p.activeSkills.includes('Chain Lightning')) {
                            arcaneDmg += playerStats.atk * 1.5;
                        }
                        arcaneDmg = Math.round(arcaneDmg);
                        monster.hp -= arcaneDmg;
                        logAction(`Arcane Power erupts for ${arcaneDmg} bonus damage!`, 'log-skill', 'battle');
                    }
                    if(arcanePowerProc && p.activeSkills.includes('Combustion')) {
                        let burnDmg = playerStats.atk * (p.activeSkills.includes('Avatar') ? 1.0 : 0.5);
                        monster.debuffs['Combustion'] = { damage: Math.round(burnDmg), duration: 3 };
                        if(p.activeSkills.includes('Avatar')) monster.debuffs['Apocalypse'] = { duration: 3 };
                        logAction('The enemy is engulfed in magical flames!', 'log-skill', 'battle');
                    }

                    let soulDrainChance = 0;
                    if(p.activeSkills.includes('Devour Soul')) soulDrainChance = 0.08;
                    else if (p.activeSkills.includes('Soul Drain')) soulDrainChance = 0.05;

                    if (soulDrainChance > 0 && Math.random() < soulDrainChance) {
                        let drainDmg = playerStats.atk * 1.5;
                        if (p.activeSkills.includes('Annihilate')) {
                            drainDmg += monster.maxHp * 0.05;
                        }
                        drainDmg = Math.round(drainDmg);
                        monster.hp -= drainDmg;
                        
                        let healPercent = p.activeSkills.includes('Devour Soul') ? 0.75 : 0.50;
                        const healAmount = Math.round(drainDmg * healPercent);
                        p.currentHp = Math.min(playerStats.hp, p.currentHp + healAmount);
                        logAction(`Soul Drain deals ${drainDmg} damage and heals you for ${healAmount}!`, 'log-skill', 'battle');

                        if (p.activeSkills.includes('Time Warp')) {
                            let missChance = p.activeSkills.includes('Paradox') ? 1.0 : 0.5;
                            if (Math.random() < missChance) {
                                monster.missNextAttack = true;
                            }
                        }
                    }
                }

                function handleBuffsAndDebuffs() {
                    const p = gameState.player;
                    const monster = gameState.currentMonster;
                    const playerStats = getPlayerTotalStats();

                    // Player buffs
                    if(gameState.playerTemp.standFirmTurns > 0) gameState.playerTemp.standFirmTurns--;
                    if(gameState.playerTemp.battleRushTurns > 0) gameState.playerTemp.battleRushTurns--;

                    // Monster debuffs
                    for (const key in monster.debuffs) {
                        const debuff = monster.debuffs[key];
                        if (debuff.duration > 0) {
                            // DoT effects
                            if (key === 'Bleed') {
                                let bleedDmg = debuff.damage * debuff.stacks;
                                if (p.activeSkills.includes('Exsanguinate') && Math.random() < playerStats.critChance) {
                                    bleedDmg = Math.round(bleedDmg * playerStats.critDmg);
                                    logAction(`Bleed critically strikes for ${bleedDmg} damage!`, 'log-skill', 'battle');
                                } else {
                                    logAction(`Bleed deals ${bleedDmg} damage.`, 'log-monster', 'battle');
                                }
                                monster.hp -= bleedDmg;
                            }
                             if (key === 'Combustion') {
                                monster.hp -= debuff.damage;
                                logAction(`Combustion burns for ${debuff.damage} damage.`, 'log-monster', 'battle');
                            }
                            debuff.duration--;
                        }
                        if (debuff.duration <= 0) {
                            delete monster.debuffs[key];
                        }
                    }
                }

                function monsterDefeated() {
                    logAction(`You have defeated the ${gameState.currentMonster.name}!`, 'log-system', "event");

                    const goldBonus = 1 + (gameState.rebirth.bonuses.gold / 100);
                    const xpRebirthBonus = 1 + (gameState.rebirth.bonuses.xp / 100);
                    const goldGained = Math.round(gameState.currentMonster.gold * goldBonus);

                    let xpShopBoostMultiplier = 1;
                    let xpLogMessage = '';
                    if (gameState.activeBoosts.xp && gameState.activeBoosts.xp.fightsRemaining > 0) {
                        xpShopBoostMultiplier = gameState.activeBoosts.xp.multiplier;
                        gameState.activeBoosts.xp.fightsRemaining--;
                        xpLogMessage = ` (x${xpShopBoostMultiplier} Boost!)`;
                        if (gameState.activeBoosts.xp.fightsRemaining <= 0) {
                            gameState.activeBoosts.xp = null;
                            logAction('Your XP Boost has expired.', 'log-boost', "event");
                        }
                    }

                    const xpGained = Math.round(gameState.currentMonster.xp * xpRebirthBonus * xpShopBoostMultiplier);

                    gameState.gold += goldGained;
                    gameState.player.xp += xpGained;
                    logAction(`You gained ${goldGained} gold and ${xpGained} XP.${xpLogMessage}`, 'log-drop', "event");

                    if (Math.random() < gameState.currentMonster.dropChance) {
                        generateItemDrop(gameState.currentMonster);
                    }

                    gameState.kills++;
                    if (gameState.currentMonster.monsterType === 'boss') {
                        gameState.wave++;
                        gameState.kills = 0;
                        UIElements.challengeBossBtn.disabled = true;
                    }

                    if (gameState.kills >= 10 && gameState.currentMonster.monsterType !== 'boss') UIElements.challengeBossBtn.disabled = false;
                    
                    while (gameState.player.xp >= gameState.player.xpToNextLevel) {
                        levelUp();
                    }

                    spawnMonster();
                }

                function playerDefeated() {
                    gameState.player.currentHp = 0;
                    logAction('You have been defeated!', 'log-monster', 'battle');
                    const xpPenalty = Math.round(gameState.player.xpToNextLevel * 0.10);
                    gameState.player.xp = Math.max(0, gameState.player.xp - xpPenalty);
                    logAction(`As a penalty, you lose ${xpPenalty} XP.`, 'log-error', "event");
                    gameState.player.currentHp = getPlayerTotalStats().hp * 0.5;
                    logAction(`You revive with 50% health.`, 'log-system', "event");
                    if (gameState.currentMonster.monsterType === 'boss') {
                        UIElements.challengeBossBtn.disabled = true;
                        spawnMonster();
                    }
                }

                function shuffleArray(array) {
                    for (let i = array.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [array[i], array[j]] = [array[j], array[i]];
                    }
                    return array;
                }

                function getRarityProbabilities(monsterType) {
                    switch (monsterType) {
                        case 'regular':
                            return { N: 0.80, R: 0.17, SR: 0.025, SSR: 0.005, UR: 0, LR: 0 };
                        case 'mutant':
                            return { N: 0.647, R: 0.30, SR: 0.04, SSR: 0.01, UR: 0.003, LR: 0 };
                        case 'elite':
                            return { N: 0.459, R: 0.40, SR: 0.10, SSR: 0.03, UR: 0.01, LR: 0.001 };
                        case 'boss':
                            return { N: 0.10, R: 0.60, SR: 0.20, SSR: 0.075, UR: 0.02, LR: 0.005 };
                        default:
                            return { N: 1.0, R: 0, SR: 0, SSR: 0, UR: 0, LR: 0 };
                    }
                }


                function generateItemDrop(monster) {
                    if (gameState.inventory.length >= gameState.maxInventorySize) {
                        logAction('Inventory is full!', 'log-system', "event"); return;
                    }

                    const classChoices = ['Warrior', 'Rogue', 'Wizard'];
                    const classForDrop = classChoices[Math.floor(Math.random() * classChoices.length)];
                    const itemType = itemData.types[Math.floor(Math.random() * itemData.types.length)];

                    const probs = getRarityProbabilities(monster.monsterType);
                    const rand = Math.random();
                    let cumulativeProb = 0;
                    let rarityKey = 'N'; // Default
                    for (const rarity in probs) {
                        if (rand < (cumulativeProb += probs[rarity])) {
                            rarityKey = rarity;
                            break;
                        }
                    }

                    const rarityInfo = itemData.rarities[rarityKey];
                    const waveScale = 1 + Math.log10(gameState.wave || 1);
                    const SET_ITEM_CHANCE = 0.10;

                    const newItem = {
                        id: Date.now() + Math.random(),
                        type: itemType,
                        rarity: rarityKey,
                        classReq: classForDrop,
                        bonusStats: {},
                        setName: null,
                        enhancementLevel: 0,
                        enhancementBonusStats: {},
                    };

                    for(const statName in STAT_NAMES) {
                        newItem.enhancementBonusStats[statName] = 0;
                    }

                    let itemName;
                    if (['SR', 'SSR', 'UR', 'LR'].includes(rarityKey) && Math.random() < SET_ITEM_CHANCE) {
                        const possibleSets = Object.keys(itemSets).filter(name => itemSets[name].class === classForDrop);
                        if (possibleSets.length > 0) {
                            const selectedSetName = possibleSets[Math.floor(Math.random() * possibleSets.length)];
                            newItem.setName = selectedSetName;
                            const setItemNames = itemSets[selectedSetName].items;
                            itemName = setItemNames[Math.floor(Math.random() * setItemNames.length)];
                        }
                    }

                    if (!newItem.setName) {
                        const possibleNames = itemData.names[itemType][classForDrop];
                        const baseName = possibleNames[Math.floor(Math.random() * possibleNames.length)];
                        const prefix = itemData.names.prefixes.Balanced[Math.floor(Math.random() * itemData.names.prefixes.Balanced.length)];
                        itemName = `${prefix} ${baseName}`;
                    }
                    newItem.name = itemName;

                    const calculateStatValue = (stat) => {
                        let value;
                        if (['critChance', 'critDmg'].includes(stat)) {
                            value = (Math.random() * 0.03 + 0.005) * rarityInfo.statMod * waveScale;
                        } else {
                            value = Math.round((Math.random() * 3 + 1) * rarityInfo.statMod * waveScale);
                        }
                        return value;
                    };

                    let coreStat = null;
                    if (newItem.type === 'weapon') coreStat = (newItem.classReq === 'Wizard') ? 'int' : 'str';
                    else if (newItem.type === 'body') coreStat = 'def';
                    else if (newItem.type === 'legs') coreStat = 'con';

                    let baseStatPool = shuffleArray([...itemData.bonusStatPool]);
                    baseStatPool = baseStatPool.filter(s => s !== coreStat);

                    if (coreStat) {
                        newItem[coreStat] = calculateStatValue(coreStat);
                    }
                    
                    const generatedBaseStats = [];
                    const baseStatsToGenerate = rarityInfo.baseStatCount - (coreStat ? 1 : 0);
                    for (let i = 0; i < baseStatsToGenerate; i++) {
                        if (baseStatPool.length === 0) break;
                        const stat = baseStatPool.pop();
                        newItem[stat] = calculateStatValue(stat);
                        generatedBaseStats.push(stat);
                    }

                    let bonusStatPool = shuffleArray([...itemData.bonusStatPool]);
                    bonusStatPool = bonusStatPool.filter(s => s !== coreStat && !generatedBaseStats.includes(s));
                    for (let i = 0; i < rarityInfo.bonusStats; i++) {
                        if (bonusStatPool.length === 0) break;
                        const stat = bonusStatPool.pop();
                        newItem.bonusStats[stat] = calculateStatValue(stat);
                    }

                    gameState.inventory.push(newItem);
                    const color = rarityInfo.color;
                    logAction(`You found a [<span style="color:${color}; font-weight: bold;">${rarityKey}</span>] <span style="color:${color}">${newItem.name}</span>!`, 'log-drop', "event");
                    updateInventoryUI();
                }

                function spawnMonster(isBoss = false) {
                    gameState.isRunning = true;
                    let monsterTemplate;
                    if (isBoss) {
                        monsterTemplate = monsters.bosses[(gameState.wave - 1) % monsters.bosses.length];
                    } else {
                        const rand = Math.random();
                        if (gameState.wave > 3 && rand < 0.15) {
                            monsterTemplate = monsters.elite[Math.floor(Math.random() * monsters.elite.length)];
                        } else if (gameState.wave > 1 && rand < 0.30) {
                            monsterTemplate = monsters.mutant[Math.floor(Math.random() * monsters.mutant.length)];
                        } else {
                            monsterTemplate = monsters.regular[Math.floor(Math.random() * monsters.regular.length)];
                        }
                    }

                    const hpScale = Math.pow(1.20, gameState.wave - 1);
                    const statScale = Math.pow(1.12, gameState.wave - 1);
                    const goldScale = Math.pow(1.15, gameState.wave - 1);
                    const xpScale = Math.pow(1.09, gameState.wave - 1);

                    gameState.currentMonster = {
                        ...monsterTemplate,
                        hp: Math.round(monsterTemplate.baseHp * hpScale),
                        maxHp: Math.round(monsterTemplate.baseHp * hpScale),
                        atk: Math.round(monsterTemplate.baseAtk * statScale),
                        def: Math.round(monsterTemplate.baseDef * statScale),
                        evasion: monsterTemplate.baseEvasion + (gameState.wave * 0.001),
                        accuracy: 0,
                        gold: Math.round(monsterTemplate.gold * goldScale),
                        xp: Math.round(monsterTemplate.xp * xpScale),
                        isBoss: isBoss,
                        debuffs: {},
                        missNextAttack: false,
                    };
                    logAction(`A wild ${gameState.currentMonster.name} appears!`, 'log-system', "event");
                    updateAllUIs();
                }

                function getAvailablePromotion(player) {
                    const baseClassInfo = classes[player.baseClassName];
                    if (!baseClassInfo || !baseClassInfo.promotions) return null;

                    const promotionTiers = Object.keys(baseClassInfo.promotions).sort((a, b) => a - b);

                    for (const tierLevel of promotionTiers) {
                        if (player.level >= tierLevel) {
                            const tier = baseClassInfo.promotions[tierLevel];
                            if (Array.isArray(tier) && player.className === player.baseClassName) {
                                return { level: tierLevel, choices: tier };
                            } else if (typeof tier === 'object' && tier[player.className]) {
                                return { level: tierLevel, choices: tier[player.className] };
                            }
                        }
                    }
                    return null;
                }

                function levelUp() {
                    const p = gameState.player;
                    
                    p.xp -= p.xpToNextLevel;
                    p.level++;
                    p.xpToNextLevel = Math.round(38 * Math.pow(p.level, 1.45));
                    
                    const pointsGained = Math.floor(Math.random() * 3) + 5;
                    p.statPoints += pointsGained;

                    let growth = { ...classes[p.baseClassName].growth };
                    const promoAdjust = promotionGrowthAdjustments[p.className];
                    if (promoAdjust) {
                        for (const stat in promoAdjust) {
                            growth[stat] = (growth[stat] || 0) + promoAdjust[stat];
                        }
                    }
                    for (const stat in growth) {
                        p.baseStats[stat] += growth[stat];
                    }

                    p.currentHp = getPlayerTotalStats().hp;
                    logAction(`LEVEL UP! You are now level ${p.level}. Gained ${pointsGained} stat points.`, 'log-system', "event");
                    logAction('Health fully restored!', 'log-system', "event");
                    if (p.level >= 70) UIElements.rebirthBtn.style.display = 'block';

                    if (!p.promotionPending) {
                        const availablePromotion = getAvailablePromotion(p);
                        if (availablePromotion) {
                            p.promotionPending = true;
                            p.pendingPromotionChoices = availablePromotion.choices;
                            showPromotionModal(availablePromotion.choices);
                        }
                    }
                    updateAllUIs();
                }

                function showPromotionModal(choices) {
                    gameState.isRunning = false;
                    UIElements.promotionDescription.textContent = 'Select a promotion to learn more.';
                    UIElements.confirmPromotionBtn.disabled = true;
                    
                    const promotionChoices = UIElements.promotionChoices;
                    promotionChoices.innerHTML = '';

                    choices.forEach(choice => {
                        const btn = document.createElement('button');
                        btn.textContent = choice;
                        btn.dataset.promotion = choice;
                        btn.onclick = () => {
                            gameState.playerTemp.promotionSelection = choice;
                            let description = promotionInfo[choice]?.description || 'No information available.';
                            const skill = promotionSkills[choice];
                            if(skill) {
                                description += `<br><br><strong>New Skill: ${skill.name}</strong> - <em>${skill.description}</em>`;
                            }
                            UIElements.promotionDescription.innerHTML = description;
                            promotionChoices.querySelectorAll('button').forEach(b => b.classList.remove('selected'));
                            btn.classList.add('selected');
                            UIElements.confirmPromotionBtn.disabled = false;
                        };
                        promotionChoices.appendChild(btn);
                    });

                    UIElements.confirmPromotionBtn.onclick = () => {
                        const selection = gameState.playerTemp.promotionSelection;
                        if (selection) {
                            gameState.player.className = selection;
                            gameState.player.promotionPending = false;
                            gameState.player.pendingPromotionChoices = null;

                            const skill = promotionSkills[selection];
                            if(skill && !gameState.player.activeSkills.includes(skill.name)) {
                                gameState.player.activeSkills.push(skill.name);
                                logAction(`You have learned the skill: <span class="log-skill">${skill.name}</span>!`, 'log-system', "event");
                            }

                            logAction(`You have been promoted to ${gameState.player.className}!`, 'log-system', "event");
                            gameState.player.currentHp = getPlayerTotalStats().hp;
                            UIElements.promotionModal.style.display = 'none';
                            gameState.isRunning = true;
                            updateAllUIs();
                        }
                    };
                    
                    UIElements.promotionModal.style.display = 'flex';
                }

                function updateUI() {
                    if (!gameState.player) return;
                    const totalStats = getPlayerTotalStats();
                    UIElements.playerName.textContent = gameState.player.name; UIElements.playerClass.textContent = gameState.player.className;
                    UIElements.playerLevel.textContent = gameState.player.level;
                    UIElements.playerHpText.textContent = `${Math.ceil(gameState.player.currentHp)} / ${Math.round(totalStats.hp)}`;
                    UIElements.playerHpFill.style.width = `${(gameState.player.currentHp / totalStats.hp) * 100}%`;
                    UIElements.playerXpText.textContent = `${gameState.player.xp} / ${gameState.player.xpToNextLevel}`;
                    UIElements.playerXpFill.style.width = `${(gameState.player.xp / gameState.player.xpToNextLevel) * 100}%`;
                    UIElements.playerAtk.textContent = Math.round(totalStats.atk); UIElements.playerDef.textContent = Math.round(totalStats.def);
                    UIElements.playerAccuracy.textContent = `${(totalStats.accuracy * 100).toFixed(1)}%`;
                    UIElements.playerEvasion.textContent = `${(totalStats.evasion * 100).toFixed(1)}%`;
                    UIElements.playerCritChance.textContent = `${(totalStats.critChance * 100).toFixed(1)}%`;
                    UIElements.playerCritDmg.textContent = `${(totalStats.critDmg * 100).toFixed(0)}%`;
                    UIElements.playerGold.textContent = gameState.gold;

                    if (gameState.currentMonster) {
                        UIElements.monsterName.textContent = gameState.currentMonster.name;
                        UIElements.monsterHpText.textContent = `${Math.ceil(gameState.currentMonster.hp)} / ${gameState.currentMonster.maxHp}`;
                        UIElements.monsterHpFill.style.width = `${(gameState.currentMonster.hp / gameState.currentMonster.maxHp) * 100}%`;
                    }
                    UIElements.waveCounter.textContent = gameState.wave; UIElements.killCounter.textContent = gameState.kills;
                    UIElements.rebirthPoints.textContent = gameState.rebirth.points; UIElements.rebirthAtk.textContent = gameState.rebirth.bonuses.atk;
                    UIElements.rebirthDef.textContent = gameState.rebirth.bonuses.def;
                    UIElements.rebirthHp.textContent = gameState.rebirth.bonuses.hp;
                    UIElements.rebirthGold.textContent = gameState.rebirth.bonuses.gold;
                    UIElements.rebirthXp.textContent = gameState.rebirth.bonuses.xp;

                    const xpBoost = gameState.activeBoosts.xp;
                    if (xpBoost && xpBoost.fightsRemaining > 0) {
                        UIElements.xpBoostStatus.textContent = `XP BOOST: x${xpBoost.multiplier} (${xpBoost.fightsRemaining} fights left)`;
                        UIElements.xpBoostStatus.style.display = 'block';
                    } else {
                        UIElements.xpBoostStatus.style.display = 'none';
                    }

                    const isBossFight = gameState.currentMonster && gameState.currentMonster.monsterType === 'boss';
                    for (const key of [25, 50, 75, 100]) {
                        const cost = gameState.potionCosts[`p${key}`];
                        const btn = UIElements[`buyPotion${key}`];
                        if (btn) {
                            btn.textContent = `Buy (${cost}G)`;
                            btn.disabled = isBossFight || gameState.gold < cost || gameState.player.currentHp >= totalStats.hp;
                        }
                    }

                    const boost2xCost = 250 * gameState.wave;
                    UIElements.buyXpBoost2x.textContent = `Buy (${boost2xCost}G)`;
                    UIElements.buyXpBoost2x.disabled = gameState.gold < boost2xCost || !!gameState.activeBoosts.xp;
                    
                    const boost3xCost = 600 * gameState.wave;
                    UIElements.buyXpBoost3x.textContent = `Buy (${boost3xCost}G)`;
                    UIElements.buyXpBoost3x.disabled = gameState.gold < boost3xCost || !!gameState.activeBoosts.xp;
                }

                function updatePointInvestmentUI() {
                    const display = UIElements.pointInvestmentDisplay;
                    display.innerHTML = '';
                    if (!gameState.player) return;

                    const p = gameState.player;
                    const allocation = gameState.playerTemp.pointAllocation;
                    const totalPending = Object.values(allocation).reduce((a, b) => a + b, 0);
                    const pointsAvailable = p.statPoints - totalPending;

                    UIElements.playerStatPoints.textContent = `${p.statPoints} (${pointsAvailable} avail)`;

                    for (const stat in p.investedStats) {
                        const statDiv = document.createElement('div');
                        statDiv.className = 'point-investment-stat';

                        const currentVal = (p.baseStats[stat] || 0) +
                            (stat === 'critChance' ? p.investedStats[stat] * 0.002 :
                                stat === 'critDmg' ? p.investedStats[stat] * 0.005 :
                                p.investedStats[stat]);

                        const pendingPoints = allocation[stat];
                        const pendingValue = (stat === 'critChance' ? pendingPoints * 0.002 :
                            stat === 'critDmg' ? pendingPoints * 0.005 :
                            pendingPoints);

                        const futureVal = currentVal + pendingValue;

                        let displayCurrent, displayFuture;
                        if (['critChance', 'critDmg'].includes(stat)) {
                            displayCurrent = `${(currentVal * 100).toFixed(1)}%`;
                            displayFuture = `${(futureVal * 100).toFixed(1)}%`;
                        } else {
                            displayCurrent = Math.round(currentVal);
                            displayFuture = Math.round(futureVal);
                        }

                        statDiv.innerHTML = `
                            <span class="stat-label">${STAT_NAMES[stat]}: <span class="stat-value">${displayCurrent}</span>
                                ${pendingPoints > 0 ? ` -> ${displayFuture}` : ''}
                            </span>
                            <div class="investment-controls">
                                <button class="btn-minus" data-stat="${stat}">-</button>
                                <span class="pending-points">${pendingPoints}</span>
                                <button class="btn-plus" data-stat="${stat}">+</button>
                            </div>
                        `;
                        const plusBtn = statDiv.querySelector('.btn-plus');
                        const minusBtn = statDiv.querySelector('.btn-minus');
                        plusBtn.disabled = pointsAvailable <= 0;
                        minusBtn.disabled = pendingPoints <= 0;

                        plusBtn.onclick = () => handlePointAllocation(stat, 1);
                        minusBtn.onclick = () => handlePointAllocation(stat, -1);

                        display.appendChild(statDiv);
                    }
                    UIElements.confirmInvestBtn.disabled = totalPending <= 0;
                    UIElements.resetInvestBtn.disabled = totalPending <= 0;
                }

                function handlePointAllocation(stat, amount) {
                    if (!gameState.player) return;
                    const allocation = gameState.playerTemp.pointAllocation;
                    const totalPending = Object.values(allocation).reduce((a, b) => a + b, 0);

                    if (amount > 0 && gameState.player.statPoints - totalPending > 0) {
                        allocation[stat]++;
                    } else if (amount < 0 && allocation[stat] > 0) {
                        allocation[stat]--;
                    }
                    updateAllUIs();
                }

                function confirmPointInvestment() {
                    if (!gameState.player) return;
                    const allocation = gameState.playerTemp.pointAllocation;
                    const totalToSpend = Object.values(allocation).reduce((a, b) => a + b, 0);

                    if (totalToSpend > 0 && gameState.player.statPoints >= totalToSpend) {
                        for (const stat in allocation) {
                            gameState.player.investedStats[stat] += allocation[stat];
                        }
                        gameState.player.statPoints -= totalToSpend;
                        logAction(`Invested ${totalToSpend} points.`, 'log-system', "event");
                        resetPointInvestment();
                    }
                }

                function resetPointInvestment() {
                    for (const stat in gameState.playerTemp.pointAllocation) {
                        gameState.playerTemp.pointAllocation[stat] = 0;
                    }
                    updateAllUIs();
                }


                function updateInventoryUI() {
                    const list = UIElements.inventoryList;
                    list.innerHTML = '';
                    const equippedIds = Object.values(gameState.equipment);
                    gameState.inventory.forEach(item => {
                        const isEquipped = equippedIds.includes(item.id);
                        const rarityColor = itemData.rarities[item.rarity].color;
                        const enhancementText = (item.enhancementLevel || 0) > 0 ? ` +${item.enhancementLevel}` : '';

                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'inventory-item';
                        itemDiv.innerHTML = `
                            <div class="inventory-item-info" data-item-id="${item.id}">
                                <span style="color: ${rarityColor};">${item.name}${enhancementText}</span>
                                ${isEquipped ? '<span class="equipped-tag">[Equipped]</span>' : ''}
                            </div>
                            <div class="inventory-item-actions">
                                <button class="equip-btn" data-item-id="${item.id}">${isEquipped ? 'Unequip' : 'Equip'}</button>
                                <button class="sell-btn" data-item-id="${item.id}">Sell</button>
                            </div>
                        `;
                        list.appendChild(itemDiv);
                    });

                    list.querySelectorAll('.inventory-item-info').forEach(el => {
                        el.onclick = (e) => {
                            const item = gameState.inventory.find(i => i.id == e.currentTarget.dataset.itemId);
                            if (item) handleTooltipToggle(e, item, equippedIds.includes(item.id));
                        };
                    });
                    list.querySelectorAll('.equip-btn').forEach(btn => {
                        btn.onclick = (e) => {
                            const item = gameState.inventory.find(i => i.id == e.currentTarget.dataset.itemId);
                            if (item) {
                                if (equippedIds.includes(item.id)) unequipItem(item.type);
                                else equipItem(item);
                            }
                        };
                    });
                    list.querySelectorAll('.sell-btn').forEach(btn => {
                        btn.onclick = (e) => sellItem(e.currentTarget.dataset.itemId);
                        btn.disabled = equippedIds.includes(parseFloat(btn.dataset.itemId));
                    });
                }

                function updateEquipmentUI() {
                    const display = UIElements.equipmentDisplay;
                    display.innerHTML = '';
                    ['weapon', 'body', 'legs'].forEach(type => {
                        const item = gameState.inventory.find(i => i.id === gameState.equipment[type]);
                        const itemSlot = document.createElement('div');
                        itemSlot.className = 'equipment-slot-display';
                        let nameHTML = '---';
                        if (item) {
                            const enhancementText = (item.enhancementLevel || 0) > 0 ? ` +${item.enhancementLevel}` : '';
                            nameHTML = `<span style="color: ${itemData.rarities[item.rarity].color};">${item.name}${enhancementText}</span>`;
                            itemSlot.onclick = (e) => handleTooltipToggle(e, item, true);
                        }
                        itemSlot.innerHTML = `<strong>${type.charAt(0).toUpperCase() + type.slice(1)}:</strong> ${nameHTML}`;
                        display.appendChild(itemSlot);
                    });
                }

                function updateSkillUI() {
                    const panel = UIElements.skillPanel;
                    const display = UIElements.skillDisplay;
                    display.innerHTML = '';

                    if (!gameState.player || gameState.player.activeSkills.length === 0) {
                        panel.style.display = 'none';
                        return;
                    }

                    panel.style.display = 'flex';
                    // Find the skill data for all active skills
                    const activeSkillData = Object.values(promotionSkills).filter(skill => gameState.player.activeSkills.includes(skill.name));
                    
                    activeSkillData.forEach(skillData => {
                        const skillDiv = document.createElement('div');
                        skillDiv.className = 'skill-entry';
                        skillDiv.innerHTML = `
                            <strong>${skillData.name}</strong>
                            <p>${skillData.description}</p>
                        `;
                        display.appendChild(skillDiv);
                    });
                }

                function handleTooltipToggle(event, item, isEquipped) {
                    event.stopPropagation();
                    if (activeTooltip.itemId === item.id) {
                        hideTooltip();
                    } else {
                        showTooltip(event.currentTarget, item, isEquipped);
                    }
                }

                function showTooltip(targetElement, item, isEquipped) {
                    hideTooltip(); 
                    
                    activeTooltip.target = targetElement;
                    activeTooltip.itemId = item.id;
                    
                    const tooltip = UIElements.globalTooltip;
                    const classColor = item.classReq === gameState.player.baseClassName ? 'var(--text-color)' : '#e06c75';
                    const enhancementText = (item.enhancementLevel || 0) > 0 ? ` +${item.enhancementLevel}` : '';

                    let content = `<strong style="color: ${itemData.rarities[item.rarity].color}; font-weight: bold;">${item.name}${enhancementText} (${item.type})</strong><br>`;
                    content += `Rarity: <span style="color: ${itemData.rarities[item.rarity].color}; font-weight: bold;">${item.rarity}</span> | Class: <span style="color:${classColor};">${item.classReq}</span><br>----<br>`;
                    
                    const buildStatString = (stat, baseValue) => {
                        const enhancementBonus = item.enhancementBonusStats?.[stat] || 0;
                        if (baseValue === 0 && enhancementBonus === 0) return '';

                        const totalValue = baseValue + enhancementBonus;
                        const isPercent = ['critChance', 'critDmg'].includes(stat);
                        let displayString;

                        if (isPercent) {
                            displayString = `+${(totalValue * 100).toFixed(1)}%`;
                            if (enhancementBonus > 0) {
                                displayString += ` (<span class="enhancement-bonus">+${(enhancementBonus * 100).toFixed(1)}%</span>)`;
                            }
                        } else {
                            displayString = `+${Math.round(totalValue)}`;
                            if (enhancementBonus > 0) {
                                displayString += ` (<span class="enhancement-bonus">+${Math.round(enhancementBonus)}</span>)`;
                            }
                        }
                        return `${STAT_NAMES[stat]}: ${displayString}<br>`;
                    };

                    let baseStatContent = '';
                    let bonusStatContent = '';

                    for (const stat in STAT_NAMES) {
                        if (item[stat] && typeof item[stat] === 'number') {
                            baseStatContent += buildStatString(stat, item[stat]);
                        } else if (item.bonusStats && item.bonusStats[stat]) {
                            bonusStatContent += buildStatString(stat, item.bonusStats[stat]);
                        }
                    }
                    
                    content += baseStatContent;
                    if (bonusStatContent) {
                        content += `---- (Bonus) ----<br>${bonusStatContent}`;
                    }


                    if (item.setName) {
                        content += `----<br><strong>${item.setName}</strong><br>`;
                        const setInfo = itemSets[item.setName];
                        const equippedCount = gameState.inventory.filter(i => i.setName === item.setName && Object.values(gameState.equipment).includes(i.id)).length;
                        for (const count in setInfo.bonuses) {
                            const bonusIsActive = equippedCount >= count;
                            content += `<span style="color: ${bonusIsActive ? 'var(--set-bonus-active)' : 'var(--disabled-text-color)'};">${setInfo.bonuses[count].description}</span><br>`;
                        }
                    }
                    
                    if (!isEquipped && gameState.equipment[item.type]) {
                        const currentStats = getPlayerTotalStats();
                        const futureStats = getPlayerTotalStats(item);
                        let comparisonContent = '----<br><strong>Comparison:</strong><br>';
                        let hasComparison = false;

                        for (const stat in DISPLAY_STATS) {
                            const diff = futureStats[stat] - currentStats[stat];
                            if (Math.abs(diff) < 0.0001) continue;
                            
                            hasComparison = true;
                            const isPercent = ['accuracy', 'evasion', 'critChance', 'critDmg'].includes(stat);
                            let diffDisplay = isPercent ? `${(diff * 100).toFixed(1)}%` : `${Math.round(diff)}`;
                            if (diff > 0) diffDisplay = `+${diffDisplay}`;

                            const symbol = diff > 0 ? '▲' : '▼';
                            const className = diff > 0 ? 'stat-increase' : 'stat-decrease';
                            
                            comparisonContent += `${DISPLAY_STATS[stat]}: <span class="${className}">${symbol}${diffDisplay}</span><br>`;
                        }
                        if (hasComparison) content += comparisonContent;
                    }

                    content += `----<br>Sell Value: ${itemData.rarities[item.rarity].value}G`;
                    tooltip.innerHTML = content;

                    tooltip.style.display = 'block';
                    const targetRect = targetElement.getBoundingClientRect();
                    const tooltipRect = tooltip.getBoundingClientRect();
                    let top = targetRect.bottom + 5;
                    let left = targetRect.left + (targetRect.width / 2) - (tooltipRect.width / 2);
                    if (top + tooltipRect.height > window.innerHeight) top = targetRect.top - tooltipRect.height - 5;
                    if (left < 0) left = 5;
                    if (left + tooltipRect.width > window.innerWidth) left = window.innerWidth - tooltipRect.width - 5;
                    tooltip.style.top = `${top}px`;
                    tooltip.style.left = `${left}px`;
                    
                    setTimeout(() => window.addEventListener('click', handleDocumentClickForTooltip), 0);
                }

                function hideTooltip() {
                    if (activeTooltip.target) {
                        UIElements.globalTooltip.style.display = 'none';
                        activeTooltip.target = null;
                        activeTooltip.itemId = null;
                        window.removeEventListener('click', handleDocumentClickForTooltip);
                    }
                }
                
                function handleDocumentClickForTooltip(event) {
                    if (activeTooltip.target && !activeTooltip.target.contains(event.target) && !UIElements.globalTooltip.contains(event.target)) {
                        hideTooltip();
                    }
                }

                function equipItem(itemToEquip) {
                    if (itemToEquip.classReq !== gameState.player.baseClassName) {
                        logAction(`Cannot equip: ${itemToEquip.name}. Requires ${itemToEquip.classReq} class.`, 'log-error', "event");
                        return;
                    }
                    gameState.equipment[itemToEquip.type] = itemToEquip.id;
                    logAction(`Equipped <span style="color:${itemData.rarities[itemToEquip.rarity].color};">${itemToEquip.name}</span>.`, 'log-system', "event");
                    hideTooltip();
                    updateAllUIs();
                }

                function unequipItem(itemType) {
                    const itemToUnequip = gameState.inventory.find(item => item.id === gameState.equipment[itemType]);
                    gameState.equipment[itemType] = null;
                    if (itemToUnequip) logAction(`Unequipped <span style="color:${itemData.rarities[itemToUnequip.rarity].color};">${itemToUnequip.name}</span>.`, 'log-system', "event");
                    hideTooltip();
                    updateAllUIs();
                }

                function sellItem(itemId) {
                    const itemIndex = gameState.inventory.findIndex(i => i.id == itemId);
                    if (itemIndex === -1) return;
                    const item = gameState.inventory[itemIndex];
                    if (Object.values(gameState.equipment).includes(item.id)) {
                        logAction("Cannot sell an equipped item.", 'log-error', "event"); return;
                    }
                    const sellValue = itemData.rarities[item.rarity].value;
                    gameState.gold += sellValue;
                    gameState.inventory.splice(itemIndex, 1);
                    logAction(`Sold <span style="color:${itemData.rarities[item.rarity].color};">${item.name}</span> for ${sellValue}G.`, 'log-system', "event");
                    hideTooltip();
                    updateAllUIs();
                }

                function logAction(message, typeClass, logType = 'event') {
                    const p = document.createElement('p');
                    p.innerHTML = message;
                    if (typeClass) p.classList.add(typeClass);

                    const targetLog = logType === 'battle' ? UIElements.battleLog : UIElements.eventLog;
                    targetLog.appendChild(p);
                    targetLog.scrollTop = targetLog.scrollHeight;
                }

                function updateAllUIs() { updateUI(); updateInventoryUI(); updateEquipmentUI(); updatePointInvestmentUI(); updateSkillUI(); updateBlacksmithUI();}

                function resetTransientData() {
                    gameState.playerTemp = {
                        pointAllocation: { str: 0, con: 0, def: 0, dex: 0, agl: 0, int: 0, critChance: 0, critDmg: 0 },
                        classSelection: null,
                        promotionSelection: null,
                        blacksmithSelection: null,
                        lastEnhancementResult: null,
                        standFirmTurns: 0,
                        battleRushTurns: 0,
                        guaranteedCrit: false,
                        guaranteedEvasion: false,
                        attacksSinceLastFocus: 0,
                    };
                    if (gameState.currentMonster) {
                        gameState.currentMonster.debuffs = {};
                        gameState.currentMonster.missNextAttack = false;
                    }
                }

                function handleNewGame() {
                    clearInterval(gameInterval); clearInterval(autoSaveInterval);
                    localStorage.removeItem(SAVE_KEY);
                    const rebirthData = gameState.rebirth;
                    gameState = getDefaultGameState();
                    gameState.rebirth = rebirthData;
                    UIElements.eventLog.innerHTML = '';
                    UIElements.battleLog.innerHTML = '';
                    logAction('The world is born anew. Choose your class.', 'log-system', "event");
                    UIElements.rebirthBtn.style.display = 'none';
                    UIElements.classSelectionModal.style.display = 'flex';
                    updateAllUIs();
                }

                function handleRebirth() {
                    if (!gameState.player || gameState.player.level < 70) return;
                    if (confirm('Are you sure you want to rebirth?')) {
                        const pointsGained = Math.floor((gameState.player.level - 69) * 1.5 + gameState.wave * 2);
                        clearInterval(gameInterval); clearInterval(autoSaveInterval);
                        localStorage.removeItem(SAVE_KEY);
                        const rebirthData = gameState.rebirth;
                        rebirthData.points += pointsGained;
                        gameState = getDefaultGameState();
                        gameState.rebirth = rebirthData;
                        logAction(`You have been reborn! Gained ${pointsGained} Rebirth Points.`, 'log-system', "event");
                        UIElements.rebirthBtn.style.display = 'none';
                        UIElements.classSelectionModal.style.display = 'flex';
                        updateAllUIs();
                    }
                }

                function investRebirthPoint(stat) {
                    if (gameState.rebirth.points > 0) {
                        gameState.rebirth.points--;
                        if (['gold', 'xp'].includes(stat)) gameState.rebirth.bonuses[stat] += 1;
                        else gameState.rebirth.bonuses[stat] += (stat === 'hp' ? 5 : 1);
                        updateAllUIs();
                    }
                }

                function sellItemsByRarity(rarity) {
                    let soldCount = 0; let goldEarned = 0;
                    const equippedIds = Object.values(gameState.equipment);
                    const itemsToKeep = gameState.inventory.filter(item => {
                        if (item.rarity === rarity && !equippedIds.includes(item.id)) {
                            goldEarned += itemData.rarities[item.rarity].value; soldCount++; return false;
                        }
                        return true;
                    });
                    if (soldCount > 0) {
                        gameState.inventory = itemsToKeep; gameState.gold += goldEarned;
                        logAction(`Sold ${soldCount} [${rarity}] items for ${goldEarned}G.`, 'log-system', "event");
                        updateAllUIs();
                    } else {
                        logAction(`No unequipped [${rarity}] items to sell.`, 'log-system', "event");
                    }
                }

                function buyPotion(percent) {
                    const cost = gameState.potionCosts[`p${percent}`];
                    const totalStats = getPlayerTotalStats();
                    if (gameState.gold >= cost && gameState.player.currentHp < totalStats.hp) {
                        gameState.gold -= cost;
                        const healAmount = totalStats.hp * (percent / 100);
                        gameState.player.currentHp = Math.min(totalStats.hp, gameState.player.currentHp + healAmount);
                        gameState.potionCosts[`p${percent}`] = Math.round(cost * 1.03);
                        logAction(`You drink a potion, restoring health.`, 'log-system', "event");
                        updateUI();
                    }
                }

                function buyXpBoost(multiplier) {
                    const baseCost = multiplier === 2 ? 250 : 600;
                    const cost = baseCost * gameState.wave;

                    if (gameState.gold >= cost && !gameState.activeBoosts.xp) {
                        gameState.gold -= cost;
                        gameState.activeBoosts.xp = {
                            multiplier: multiplier,
                            fightsRemaining: 100
                        };
                        logAction(`Purchased a x${multiplier} XP Boost for 100 fights!`, 'log-boost', "event");
                        updateAllUIs();
                    }
                }

                // --- BLACKSMITH (REWORKED) ---
                function updateBlacksmithUI() {
                    const selector = UIElements.blacksmithItemSelector;
                    selector.innerHTML = '';

                    ['weapon', 'body', 'legs'].forEach(type => {
                        const item = gameState.inventory.find(i => i.id === gameState.equipment[type]);
                        const slot = document.createElement('div');
                        slot.className = 'blacksmith-slot';
                        slot.dataset.type = type;
                        
                        if (item) {
                            const enhancementText = (item.enhancementLevel || 0) > 0 ? ` +${item.enhancementLevel}` : '';
                            slot.innerHTML = `<span style="color: ${itemData.rarities[item.rarity].color};">${item.name}${enhancementText}</span>`;
                        } else {
                            slot.innerHTML = `[${type.charAt(0).toUpperCase() + type.slice(1)} Slot]`;
                            slot.style.color = 'var(--disabled-text-color)';
                        }
                        
                        if (gameState.playerTemp.blacksmithSelection === type) {
                            slot.classList.add('selected');
                        }

                        slot.onclick = () => selectBlacksmithItem(type);
                        selector.appendChild(slot);
                    });

                    updateEnhancementPanel();
                }

                function selectBlacksmithItem(type) {
                    gameState.playerTemp.blacksmithSelection = type;
                    gameState.playerTemp.lastEnhancementResult = null; // Clear last result on new selection
                    updateBlacksmithUI();
                }

                function getEnhancementCost(item) {
                    if (!item) return 0;
                    const baseCost = 50;
                    const rarityMod = itemData.rarities[item.rarity].enhanceCostMod;
                    const levelMod = Math.pow(1.4, (item.enhancementLevel || 0));
                    return Math.round(baseCost * rarityMod * levelMod);
                }

                function updateEnhancementPanel() {
                    const panel = UIElements.blacksmithEnhancementPanel;
                    const infoDiv = UIElements.enhancementInfo;
                    const btn = UIElements.enhanceItemBtn;
                    const selectedType = gameState.playerTemp.blacksmithSelection;
                    const item = gameState.inventory.find(i => i.id === gameState.equipment[selectedType]);

                    if (!item) {
                        panel.style.display = 'none';
                        return;
                    }
                    panel.style.display = 'block';

                    const cost = getEnhancementCost(item);
                    const currentLevel = item.enhancementLevel || 0;
                    const MAX_ENHANCEMENT = 10;
                    const lastResult = gameState.playerTemp.lastEnhancementResult;

                    let infoHTML = `
                        <p style="text-align:center;"><strong style="color: ${itemData.rarities[item.rarity].color};">${item.name} (${item.rarity})</strong></p>
                        <p>Enhancement: <strong>+${currentLevel} -> +${currentLevel >= MAX_ENHANCEMENT ? currentLevel : '?'}</strong></p>
                        <hr style="border-color: var(--border-color);">
                    `;
                    
                    const statPool = [];
                    for (const stat in STAT_NAMES) {
                        if ((item[stat] && typeof item[stat] === 'number') /*|| (item.bonusStats && item.bonusStats[stat])*/) {
                            statPool.push(stat);
                        }
                    }

                    if (currentLevel >= MAX_ENHANCEMENT) {
                        infoHTML += `<p style="text-align:center;">Max Level Reached</p>`;
                        btn.disabled = true;
                    } else if (statPool.length > 0) {
                        statPool.forEach(stat => {
                            const baseValue = (item[stat] || 0) /*+ (item.bonusStats?.[stat] || 0)*/;
                            const enhancementBonus = item.enhancementBonusStats?.[stat] || 0;
                            const totalValue = baseValue + enhancementBonus;
                            const isPercent = ['critChance', 'critDmg'].includes(stat);
                            const displayValue = isPercent ? `${(totalValue * 100).toFixed(1)}%` : Math.round(totalValue);

                            let statLine = `<p>${STAT_NAMES[stat]}: ${displayValue} -> ?`;
                            if (lastResult && lastResult.stat === stat) {
                                statLine = `<p>${STAT_NAMES[stat]}: ${displayValue} <span class="stat-increase"><-- Just Enhanced!</span>`;
                            }
                            infoHTML += `${statLine}</p>`;
                        });
                        infoHTML += `<hr style="border-color: var(--border-color);"><p style="text-align:center;">Cost: <span style="color: var(--gold-color);">${cost}G</span></p>`;
                        btn.disabled = gameState.gold < cost;
                    } else {
                        infoHTML += `<p style="text-align:center;">This item has no stats to enhance.</p>`;
                        btn.disabled = true;
                    }
                    
                    infoDiv.innerHTML = infoHTML;
                }

                function enhanceSelectedItem() {
                    const selectedType = gameState.playerTemp.blacksmithSelection;
                    const item = gameState.inventory.find(i => i.id === gameState.equipment[selectedType]);
                    if (!item) return;

                    const currentLevel = item.enhancementLevel || 0;
                    const MAX_ENHANCEMENT = 10;
                    if (currentLevel >= MAX_ENHANCEMENT) {
                        logAction("This item is already at max enhancement level.", "log-error", "event");
                        return;
                    }

                    const cost = getEnhancementCost(item);
                    if (gameState.gold < cost) {
                        logAction('Not enough gold to enhance.', 'log-error', "event");
                        return;
                    }
                    
                    const statPool = [];
                    for (const stat in STAT_NAMES) {
                        if ((item[stat] && typeof item[stat] === 'number') /*|| (item.bonusStats && item.bonusStats[stat])*/) {
                            statPool.push(stat);
                        }
                    }

                    if (statPool.length === 0) {
                        logAction("This item has no stats to enhance.", "log-error", "event");
                        return;
                    }
                    
                    gameState.gold -= cost;

                    const statToEnhance = statPool[Math.floor(Math.random() * statPool.length)];
                    let increase = 0;
                    let isPercent = false;

                    if (statToEnhance === 'critChance') {
                        increase = 0.003; isPercent = true;
                    } else if (statToEnhance === 'critDmg') {
                        increase = 0.01; isPercent = true;
                    } else {
                        const baseValue = (item[statToEnhance] || 0) /*+ (item.bonusStats?.[statToEnhance] || 0)*/;
                        increase = 1 + Math.round(baseValue * 0.10);
                    }
                    
                    item.enhancementBonusStats[statToEnhance] = (item.enhancementBonusStats[statToEnhance] || 0) + increase;
                    item.enhancementLevel = currentLevel + 1;
                    
                    gameState.playerTemp.lastEnhancementResult = { stat: statToEnhance };

                    const displayIncrease = isPercent ? `${(increase * 100).toFixed(1)}%` : `+${increase}`;
                    logAction(`Successfully enhanced <span style="color:${itemData.rarities[item.rarity].color};">${item.name}</span>! ${STAT_NAMES[statToEnhance]} increased by ${displayIncrease}.`, 'log-system', "event");
                    
                    updateAllUIs();
                }


                function isObject(item) { return (item && typeof item === 'object' && !Array.isArray(item)); }
                function deepMerge(target, source) {
                    let output = { ...target };
                    if (isObject(target) && isObject(source)) {
                        Object.keys(source).forEach(key => {
                            if (isObject(source[key]) && key in target && isObject(target[key])) {
                                output[key] = deepMerge(target[key], source[key]);
                            } else {
                                output[key] = source[key];
                            }
                        });
                    }
                    return output;
                }

                function setupTabs() {
                    document.querySelectorAll('.tab-button').forEach(button => {
                        button.addEventListener('click', () => {
                            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                            button.classList.add('active');
                            const tabId = button.getAttribute('data-tab');
                            document.querySelectorAll('.tab-content').forEach(content => {
                                content.classList.toggle('active', content.id === `tab-content-${tabId}`);
                            });
                            if (tabId === 'blacksmith') {
                                updateBlacksmithUI();
                            }
                        });
                    });
                }

                function setupLogTabs() {
                    document.querySelectorAll('.log-tab-button').forEach(button => {
                        button.addEventListener('click', () => {
                            document.querySelectorAll('.log-tab-button').forEach(btn => btn.classList.remove('active'));
                            button.classList.add('active');
                            const tabId = button.getAttribute('data-log-tab');
                            document.querySelectorAll('.log-tab-content').forEach(content => {
                                content.classList.toggle('active', content.id === `${tabId}-log`);
                            });
                        });
                    });
                }
                
                function setupClassSelectionEvents() {
                    const choiceButtons = UIElements.classSelectionChoices.querySelectorAll('button');
                    
                    choiceButtons.forEach(btn => {
                        btn.addEventListener('click', () => {
                            const className = btn.dataset.class;
                            gameState.playerTemp.classSelection = className;
                            UIElements.classDescription.textContent = classes[className].description;
                            
                            choiceButtons.forEach(b => b.classList.remove('selected'));
                            btn.classList.add('selected');
                            
                            UIElements.confirmClassBtn.disabled = false;
                        });
                    });

                    UIElements.confirmClassBtn.addEventListener('click', () => {
                        if (gameState.playerTemp.classSelection) {
                            selectClass(gameState.playerTemp.classSelection);
                        }
                    });
                }

                // --- EVENT LISTENERS ---
                UIElements.manualSaveBtn.onclick = manualSave;
                UIElements.manualLoadBtn.onclick = manualLoad;
                UIElements.closeSaveModalBtn.onclick = () => { UIElements.manualSaveModal.style.display = 'none'; };
                UIElements.newGameBtn.onclick = handleNewGame;
                UIElements.rebirthBtn.onclick = handleRebirth;
                UIElements.challengeBossBtn.onclick = () => {
                    spawnMonster(true);
                    gameState.player.currentHp = getPlayerTotalStats().hp;
                    UIElements.challengeBossBtn.disabled = true;
                    updateUI();
                };
                UIElements.buyPotion25.onclick = () => buyPotion(25);
                UIElements.buyPotion50.onclick = () => buyPotion(50);
                UIElements.buyPotion75.onclick = () => buyPotion(75);
                UIElements.buyPotion100.onclick = () => buyPotion(100);
                UIElements.buyXpBoost2x.onclick = () => buyXpBoost(2);
                UIElements.buyXpBoost3x.onclick = () => buyXpBoost(3);
                document.querySelectorAll('#tab-content-rebirth .rebirth-stat button').forEach(btn => {
                    btn.onclick = () => investRebirthPoint(btn.dataset.rebirth);
                });
                UIElements.sellNBtn.onclick = () => sellItemsByRarity('N');
                UIElements.sellRBtn.onclick = () => sellItemsByRarity('R');
                UIElements.confirmInvestBtn.onclick = confirmPointInvestment;
                UIElements.resetInvestBtn.onclick = resetPointInvestment;
                UIElements.enhanceItemBtn.onclick = enhanceSelectedItem;

                initializeGame();
            });
        </script>
</body>

</html>

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Idle RPG Evolved</title>
    <style>
        :root {
            --bg-color: #0a0a0a;
            --panel-bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --primary-color: #444444;
            /* Enabled button color */
            --secondary-color: #333333;
            --border-color: #2c2c2c;
            --header-bg-color: #000000;
            --hp-color: #8C5656;
            --xp-color: #56608C;
            --gold-color: #c7a552;
            --rebirth-color: #724394;
            --disabled-bg-color: #222222;
            --disabled-text-color: #555555;
            --skill-color: #ffffff;
            --stat-str: #c97d7d;
            --stat-con: #7dc982;
            --stat-def: #7d8ec9;
            --stat-dex: #c9c27d;
            --stat-agl: #c99b7d;
            --stat-int: #a37dc9;
        }

        body {
            font-family: 'Verdana', 'Geneva', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            font-size: 14px;
        }

        .main-container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 280px;
            background-color: var(--panel-bg-color);
            border-right: 1px solid var(--border-color);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .main-content {
            flex-grow: 1;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
        }

        .panel {
            background-color: var(--panel-bg-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: inset 0 0 10px #000;
        }

        .panel-footer {
            padding: 10px;
            border-top: 1px solid var(--border-color);
            background-color: var(--header-bg-color);
            display: flex;
            gap: 10px;
        }

        #system-panel {
            margin-top: auto;
        }

        .panel-header {
            background-color: var(--header-bg-color);
            padding: 10px 15px;
            font-weight: bold;
            border-bottom: 1px solid var(--border-color);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 13px;
        }

        .panel-body {
            padding: 15px;
        }

        .stat-bar {
            background-color: #0a0a0a;
            border-radius: 2px;
            overflow: hidden;
            margin: 5px 0 10px;
            height: 20px;
            border: 1px solid #000;
        }

        .stat-bar-fill {
            height: 100%;
            transition: width 0.3s ease-in-out;
            text-align: center;
            font-size: 12px;
            line-height: 20px;
            color: #000;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.1);
        }

        #player-hp-fill {
            background-color: var(--hp-color);
        }

        #player-xp-fill {
            background-color: var(--xp-color);
        }

        #monster-hp-fill {
            background-color: #999999;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px 12px;
            font-size: 13px;
        }

        .monster-area {
            text-align: center;
        }

        #monster-name {
            font-size: 1.5em;
            font-weight: bold;
            margin: 20px 0;
            color: #ffffff;
        }

        .activity-log-container {
            height: 200px;
            overflow-y: auto;
            border: 1px solid #000;
            padding: 10px;
            background-color: #111;
            border-radius: 3px;
            flex-grow: 1;
        }

        .activity-log-container p {
            margin: 0 0 5px;
            font-size: 13px;
        }

        #global-tooltip {
            display: none;
            position: fixed;
            background-color: #111;
            color: var(--text-color);
            padding: 10px;
            border-radius: 4px;
            z-index: 1000;
            width: 250px;
            font-size: 13px;
            border: 1px solid var(--border-color);
            white-space: pre-wrap;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            pointer-events: auto;
        }

        button,
        .button {
            background-color: var(--primary-color);
            color: var(--text-color);
            border: 1px solid #000;
            padding: 8px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.2s;
            width: 100%;
            margin-top: 5px;
            text-align: center;
            display: inline-block;
            box-sizing: border-box;
        }

        button:hover:not(:disabled) {
            background-color: #555555;
        }

        button:disabled {
            background-color: var(--disabled-bg-color);
            color: var(--disabled-text-color);
            cursor: not-allowed;
        }

        .button-secondary {
            background-color: var(--secondary-color);
            color: var(--text-color);
        }

        .button-secondary:hover:not(:disabled) {
            background-color: #444444;
        }

        .button-danger {
            background-color: #505050;
            color: var(--text-color);
        }

        .button-danger:hover:not(:disabled) {
            background-color: #616161;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: var(--panel-bg-color);
            margin: auto;
            padding: 30px;
            border: 1px solid var(--border-color);
            width: 80%;
            max-width: 500px;
            border-radius: 4px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        .modal-choices {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        .modal-choices button {
            width: auto;
            padding: 12px 20px;
        }

        #manual-save-textarea {
            width: 100%;
            height: 120px;
            background-color: #0a0a0a;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            margin: 15px 0;
            font-family: monospace;
            font-size: 12px;
            word-break: break-all;
        }

        .gold-display {
            font-size: 1.2em;
            color: var(--gold-color);
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
        }

        .log-player {
            color: #bbbbbb;
        }

        .log-monster {
            color: #999999;
        }

        .log-system {
            color: #e0e0e0;
        }

        .log-drop {
            color: var(--gold-color);
        }

        .log-error {
            color: #ffffff;
            font-weight: bold;
        }

        .log-skill {
            color: var(--skill-color);
            font-style: italic;
            font-weight: bold;
        }

        .point-investment-stat,
        .rebirth-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .point-investment-stat .stat-label {
            flex-grow: 1;
        }

        .investment-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .investment-controls button {
            width: 28px;
            height: 28px;
            padding: 0;
            font-size: 1.2em;
            flex-shrink: 0;
            margin: 0;
        }

        .pending-points {
            font-weight: bold;
            color: var(--gold-color);
            min-width: 20px;
            text-align: center;
        }

        .stat-value {
            color: var(--rebirth-color);
            font-weight: bold;
        }

        .equipment-slot-display {
            padding: 4px 0;
            position: relative;
            cursor: pointer;
        }

        .tab-buttons {
            display: flex;
            padding: 0;
            border-bottom: 1px solid var(--border-color);
        }

        .tab-button {
            flex: 1;
            border: none;
            background-color: var(--panel-bg-color);
            color: var(--text-color);
            padding: 10px;
            cursor: pointer;
            transition: background-color 0.2s, border-bottom-color 0.2s;
            border-radius: 0;
            margin: 0;
            border-bottom: 3px solid transparent;
        }

        .tab-button.active {
            border-bottom-color: var(--text-color);
            font-weight: bold;
            background-color: var(--header-bg-color);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        #inventory-list {
            max-height: 250px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .inventory-item {
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
            position: relative;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .inventory-item-info {
            cursor: pointer;
            flex-grow: 1;
        }

        .inventory-item-actions {
            display: flex;
            gap: 5px;
            flex-shrink: 0;
        }

        .inventory-item-actions button {
            width: auto;
            padding: 4px 8px;
            font-size: 11px;
            margin-top: 0;
        }

        .equipped-tag {
            color: #ffffff;
            font-size: 0.8em;
            margin-left: 8px;
            font-style: italic;
            font-weight: bold;
        }

        .tooltip-button {
            width: 100%;
            box-sizing: border-box;
            padding: 6px;
            margin-top: 10px;
            font-size: 12px;
        }

        #skill-display .skill-entry {
            margin-bottom: 10px;
        }

        #skill-display strong {
            color: var(--skill-color);
            font-size: 14px;
        }

        #skill-display p {
            margin: 5px 0 0;
            font-style: italic;
            color: #ccc;
            font-size: 12px;
        }

        .shop-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
        }

        .shop-item {
            border: 1px solid var(--border-color);
            border-radius: 3px;
            padding: 10px;
            text-align: center;
            background-color: var(--header-bg-color);
        }

        .shop-item button {
            margin-top: 10px;
        }

        @media (max-width: 900px) {
            .main-container {
                flex-direction: column;
                height: auto;
                padding: 10px;
            }

            .sidebar {
                display: contents;
            }

            .main-content {
                order: 1;
                padding: 0;
            }

            .panel {
                width: auto;
                margin-bottom: 15px;
            }

            #system-panel {
                order: 99;
                margin-top: 0;
                margin-bottom: 0;
            }
        }
    </style>
</head>

<body>

    <div class="main-container">
        <div class="sidebar">
            <div class="panel">
                <div class="panel-header">Player Profile</div>
                <div class="panel-body">
                    <div id="player-info">
                        <div>Name: <span id="player-name">Player</span></div>
                        <div>Class: <span id="player-class">N/A</span></div>
                        <div>Level: <span id="player-level">1</span></div>
                        <div>Stat Points: <span id="player-stat-points" style="color: var(--gold-color); font-weight: bold;">0</span></div>
                    </div>
                    <hr style="border-color: var(--border-color);">
                    <div>HP: <span id="player-hp-text">100 / 100</span></div>
                    <div class="stat-bar">
                        <div class="stat-bar-fill" id="player-hp-fill"></div>
                    </div>
                    <div>XP: <span id="player-xp-text">0 / 100</span></div>
                    <div class="stat-bar">
                        <div class="stat-bar-fill" id="player-xp-fill"></div>
                    </div>
                    <div class="gold-display">Gold: <span id="player-gold">0</span>G</div>
                </div>
            </div>
            <div class="panel">
                <div class="panel-header">Combat Stats</div>
                <div class="panel-body stats-grid">
                    <div>ATK: <span id="player-atk">10</span></div>
                    <div>DEF: <span id="player-def">5</span></div>
                    <div>Accuracy: <span id="player-accuracy">5%</span></div>
                    <div>Evasion: <span id="player-evasion">5%</span></div>
                    <div>Crit Chance: <span id="player-crit-chance">5%</span></div>
                    <div>Crit DMG: <span id="player-crit-dmg">150%</span></div>
                </div>
            </div>
            <div class="panel">
                <div class="panel-header">Invest Points</div>
                <div class="panel-body" id="point-investment-display">
                    <!-- Dynamic content here -->
                </div>
                <div class="panel-footer" id="investment-actions">
                    <button id="confirm-invest-btn">Confirm</button>
                    <button id="reset-invest-btn" class="button-secondary">Reset</button>
                </div>
            </div>
            <div class="panel">
                <div class="panel-header">Equipment</div>
                <div class="panel-body" id="equipment-display"></div>
            </div>
            <div class="panel" id="skill-panel" style="display: none;">
                <div class="panel-header">Active Skills</div>
                <div class="panel-body" id="skill-display"></div>
            </div>
            <div class="panel" id="system-panel">
                <div class="panel-header">System</div>
                <div class="panel-body" style="display: flex; flex-direction: column; gap: 10px;">
                    <button id="manual-save-btn">Export Save</button>
                    <button id="manual-load-btn">Import Save</button>
                    <hr style="border-color: var(--border-color);">
                    <button id="new-game-btn" class="button-danger">New Game</button>
                    <button id="rebirth-btn" class="button-danger" style="display: none;">Rebirth</button>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="panel">
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="combat">Combat</button>
                    <button class="tab-button" data-tab="shop">Shop</button>
                    <button class="tab-button" data-tab="inventory">Inventory</button>
                    <button class="tab-button" data-tab="rebirth">Rebirth</button>
                </div>
                <div class="panel-body">
                    <div id="tab-content-combat" class="tab-content active">
                        <div class="panel monster-area" style="margin: 0; border: none; box-shadow: none;">
                            <div class="panel-body">
                                <h2 id="monster-name">Monster</h2>
                                <div>HP: <span id="monster-hp-text">50 / 50</span></div>
                                <div class="stat-bar">
                                    <div class="stat-bar-fill" id="monster-hp-fill"></div>
                                </div>
                                <div>Wave: <span id="wave-counter">1</span> | Kills: <span id="kill-counter">0</span></div>
                                <button id="challenge-boss-btn" disabled>Challenge Boss</button>
                            </div>
                        </div>
                    </div>
                    <div id="tab-content-shop" class="tab-content">
                        <div class="shop-grid">
                            <div class="shop-item">
                                <strong>Minor Potion</strong>
                                <p>Heals 25% HP</p>
                                <button id="buy-potion-25">Buy (15G)</button>
                            </div>
                            <div class="shop-item">
                                <strong>Standard Potion</strong>
                                <p>Heals 50% HP</p>
                                <button id="buy-potion-50">Buy (28G)</button>
                            </div>
                            <div class="shop-item">
                                <strong>Greater Potion</strong>
                                <p>Heals 75% HP</p>
                                <button id="buy-potion-75">Buy (40G)</button>
                            </div>
                            <div class="shop-item">
                                <strong>Full Restore</strong>
                                <p>Heals 100% HP</p>
                                <button id="buy-potion-100">Buy (50G)</button>
                            </div>
                        </div>
                    </div>
                    <div id="tab-content-inventory" class="tab-content">
                        <div id="inventory-list"></div>
                        <div class="inventory-actions" style="margin-top: 10px; display: flex; gap: 10px;">
                            <button id="sell-n-btn" class="button-secondary" style="flex: 1;">Sell All N</button>
                            <button id="sell-r-btn" class="button-secondary" style="flex: 1;">Sell All R</button>
                        </div>
                    </div>
                    <div id="tab-content-rebirth" class="tab-content">
                        <div class="rebirth-points" style="color: var(--rebirth-color); font-weight: bold; font-size: 1.5em; text-align: center; margin-bottom: 15px;">
                            Points: <span id="rebirth-points">0</span></div>
                        <div class="rebirth-stat"><span>ATK Bonus: +<span id="rebirth-atk" class="rebirth-value">0</span></span><button data-rebirth="atk">+</button></div>
                        <div class="rebirth-stat"><span>DEF Bonus: +<span id="rebirth-def" class="rebirth-value">0</span></span><button data-rebirth="def">+</button></div>
                        <div class="rebirth-stat"><span>HP Bonus: +<span id="rebirth-hp" class="rebirth-value">0</span></span><button data-rebirth="hp">+</button></div>
                        <div class="rebirth-stat"><span>Gold Bonus: +<span id="rebirth-gold" class="rebirth-value">0</span>%</span><button data-rebirth="gold">+</button></div>
                        <div class="rebirth-stat"><span>XP Bonus: +<span id="rebirth-xp" class="rebirth-value">0</span>%</span><button data-rebirth="xp">+</button>
                        </div>
                    </div>
                </div>
                <div class="panel" style="flex-grow: 1; margin-top: 15px;">
                    <div class="panel-header">Action Log</div>
                    <div class="panel-body activity-log-container" id="action-log">
                    </div>
                </div>
            </div>
        </div>

        <!-- Modals -->
        <div id="class-selection-modal" class="modal">
            <div class="modal-content">
                <h2>Choose Your Class</h2>
                <p>Your starting class determines your base stats and future path.</p>
                <div class="modal-choices">
                    <button id="select-warrior">Warrior</button>
                    <button id="select-rogue">Rogue</button>
                    <button id="select-wizard">Wizard</button>
                </div>
            </div>
        </div>
        <div id="promotion-modal" class="modal">
            <div class="modal-content">
                <h2 id="promotion-title">Class Promotion!</h2>
                <p id="promotion-text">You have reached a new milestone. Choose your path:</p>
                <div class="modal-choices" id="promotion-choices"></div>
            </div>
        </div>
        <div id="manual-save-modal" class="modal">
            <div class="modal-content">
                <h2>Game Saved!</h2>
                <p>Copy this code and save it somewhere safe. Use the Import Save button to restore your progress.</p>
                <textarea id="manual-save-textarea" readonly></textarea>
                <button id="close-save-modal-btn">Close</button>
            </div>
        </div>

        <!-- Global Tooltip -->
        <div id="global-tooltip"></div>

        <script>
            document.addEventListener('DOMContentLoaded', () => {
                let gameInterval;
                let autoSaveInterval;
                let tooltipHideTimer;
                const SAVE_KEY = 'idleRpgSaveData_v4'; // Changed key for new structure

                const STAT_NAMES = {
                    str: 'STR', con: 'CON', def: 'DEF', dex: 'DEX',
                    agl: 'AGL', int: 'INT', critChance: 'Crit Chance', critDmg: 'Crit DMG'
                };

                function getDefaultGameState() {
                    return {
                        player: null, currentMonster: null, wave: 1, kills: 0, gold: 0, isRunning: false,
                        potionCosts: { p25: 15, p50: 28, p75: 40, p100: 50 },
                        inventory: [],
                        equipment: { weapon: null, body: null, legs: null },
                        maxInventorySize: 20,
                        rebirth: { points: 0, bonuses: { atk: 0, def: 0, hp: 0, gold: 0, xp: 0 } },
                        playerTemp: {
                            pointAllocation: { str: 0, con: 0, def: 0, dex: 0, agl: 0, int: 0, critChance: 0, critDmg: 0 }
                        }
                    };
                }

                let gameState = getDefaultGameState();

                const classes = {
                    'Warrior': {
                        primaryStat: 'str',
                        base: { hp: 120, str: 10, con: 8, def: 6, dex: 3, agl: 2, int: 1, critChance: 0.05, critDmg: 1.5 },
                        growth: { str: 2, con: 2, def: 1, dex: 0.5, agl: 0.5, int: 0, critChance: 0.0005, critDmg: 0 },
                        promotions: { 20: ['Knight', 'Berserker'], 40: { 'Knight': ['Paladin', 'Guardian'], 'Berserker': ['Slayer', 'Warlord'] }, 70: { 'Paladin': ['Holy Knight'], 'Guardian': ['Aegis'], 'Slayer': ['Executioner'], 'Warlord': ['Conqueror'] } }
                    },
                    'Rogue': {
                        primaryStat: 'str',
                        base: { hp: 90, str: 12, con: 5, def: 3, dex: 8, agl: 6, int: 1, critChance: 0.10, critDmg: 1.75 },
                        growth: { str: 2, con: 1, def: 0.5, dex: 2, agl: 1, int: 0, critChance: 0.001, critDmg: 0 },
                        promotions: { 20: ['Assassin', 'Ranger'], 40: { 'Assassin': ['Shadow', 'Reaper'], 'Ranger': ['Sharpshooter', 'Pathfinder'] }, 70: { 'Shadow': ['Phantom'], 'Reaper': ['Soul Carver'], 'Sharpshooter': ['Deadeye'], 'Pathfinder': ['Trailblazer'] } }
                    },
                    'Wizard': {
                        primaryStat: 'int',
                        base: { hp: 80, str: 2, con: 4, def: 2, dex: 6, agl: 3, int: 12, critChance: 0.07, critDmg: 1.6 },
                        growth: { str: 0, con: 1, def: 0.5, dex: 1, agl: 0.5, int: 3, critChance: 0.0007, critDmg: 0 },
                        promotions: { 20: ['Mage', 'Sorcerer'], 40: { 'Mage': ['Archmage', 'Elementalist'], 'Sorcerer': ['Warlock', 'Chronomancer'] }, 70: { 'Archmage': ['Grand Magus'], 'Elementalist': ['Avatar'], 'Warlock': ['Demonologist'], 'Chronomancer': ['Time Lord'] } }
                    },
                };

                const promotionGrowthAdjustments = {
                    'Knight': { con: 1, def: 1, str: -1 }, 'Berserker': { str: 1, critChance: 0.001, con: -1 },
                    'Assassin': { str: 1, dex: 1, agl: 1, critChance: 0.0005, con: -1 }, 'Ranger': { dex: 1, agl: 1, str: 0, con: -1 },
                    'Mage': { int: 1, str: 1, dex: -1 }, 'Sorcerer': { int: 1, dex: 1, str: -1 }
                };


                const promotionSkills = {
                    // ... (no changes here, keeping them as is)
                };

                const monsters = {
                    regular: [
                        { name: 'Slime', baseHp: 30, baseAtk: 5, baseDef: 2, baseEvasion: 0.01, gold: 2, xp: 5, dropChance: 0.15 },
                        { name: 'Giant Rat', baseHp: 25, baseAtk: 6, baseDef: 1, baseEvasion: 0.03, gold: 1, xp: 4, dropChance: 0.10 },
                        { name: 'Goblin Scout', baseHp: 40, baseAtk: 7, baseDef: 3, baseEvasion: 0.05, gold: 3, xp: 6, dropChance: 0.20 },
                        { name: 'Cave Bat', baseHp: 20, baseAtk: 8, baseDef: 0, baseEvasion: 0.08, gold: 1, xp: 3, dropChance: 0.08 }
                    ],
                    elite: [
                        { name: 'Orc Grunt', baseHp: 120, baseAtk: 20, baseDef: 8, baseEvasion: 0.05, gold: 20, xp: 30, dropChance: 0.8, isElite: true },
                        { name: 'Troll', baseHp: 150, baseAtk: 18, baseDef: 12, baseEvasion: 0.02, gold: 25, xp: 40, dropChance: 0.9, isElite: true },
                        { name: 'Ogre Mage', baseHp: 100, baseAtk: 28, baseDef: 6, baseEvasion: 0.04, gold: 30, xp: 50, dropChance: 0.85, isElite: true }
                    ],
                    bosses: [
                        { name: 'Grimgnaw the Goblin King', baseHp: 400, baseAtk: 35, baseDef: 15, baseEvasion: 0.06, gold: 150, xp: 200, dropChance: 1.0 },
                        { name: 'The Slime Mother', baseHp: 600, baseAtk: 30, baseDef: 25, baseEvasion: 0.03, gold: 250, xp: 350, dropChance: 1.0 }
                    ]
                };
                const itemData = {
                    types: ['weapon', 'body', 'legs'],
                    rarities: {
                        N: { color: '#DEDEDE', statMod: 1.0, value: 2, bonusStats: 0 },
                        R: { color: '#63C270', statMod: 1.2, value: 8, bonusStats: 1 },
                        SR: { color: '#6386C2', statMod: 1.5, value: 40, bonusStats: 2 },
                        SSR: { color: '#9663C2', statMod: 2.0, value: 200, bonusStats: 3 },
                        UR: { color: '#C29463', statMod: 2.8, value: 1000, bonusStats: 4 },
                    },
                    baseStats: {
                        weapon: { str: 5, int: 5 },
                        body: { def: 4, con: 10 },
                        legs: { def: 2, agl: 3 }
                    },
                    bonusStatPool: Object.keys(STAT_NAMES),
                    names: {
                        weapon: {
                            Warrior: ['Sword', 'Axe', 'Gauntlet'],
                            Rogue: ['Dagger', 'Bow', 'Claw'],
                            Wizard: ['Staff', 'Wand', 'Rod']
                        },
                        body: {
                            Warrior: ['Armor', 'Vest'],
                            Rogue: ['Leather', 'Jacket'],
                            Wizard: ['Robe', 'Cape']
                        },
                        legs: {
                            Warrior: ['Greaves', 'Sabatons'],
                            Rogue: ['Boots', 'Slippers'],
                            Wizard: ['Shoes', 'Wraps']
                        },
                        prefixes: {
                            Warrior: ['Mighty', 'Stalwart', 'Brutal', 'Savage', 'Guardian\'s'],
                            Rogue: ['Swift', 'Silent', 'Vicious', 'Shadow', 'Assassin\'s'],
                            Wizard: ['Arcane', 'Mystic', 'Elemental', 'Warlock\'s', 'Sage\'s'],
                            Balanced: ['Fine', 'Superior', 'Masterwork', 'Exquisite', 'Perfect']
                        }
                    }
                };

                const UIElements = {
                    playerName: document.getElementById('player-name'), playerClass: document.getElementById('player-class'),
                    playerLevel: document.getElementById('player-level'), playerStatPoints: document.getElementById('player-stat-points'),
                    playerHpText: document.getElementById('player-hp-text'), playerHpFill: document.getElementById('player-hp-fill'),
                    playerXpText: document.getElementById('player-xp-text'), playerXpFill: document.getElementById('player-xp-fill'),
                    playerAtk: document.getElementById('player-atk'), playerDef: document.getElementById('player-def'),
                    playerCritChance: document.getElementById('player-crit-chance'), playerCritDmg: document.getElementById('player-crit-dmg'),
                    playerEvasion: document.getElementById('player-evasion'), playerAccuracy: document.getElementById('player-accuracy'),
                    playerGold: document.getElementById('player-gold'), monsterName: document.getElementById('monster-name'),
                    monsterHpText: document.getElementById('monster-hp-text'), monsterHpFill: document.getElementById('monster-hp-fill'),
                    waveCounter: document.getElementById('wave-counter'), killCounter: document.getElementById('kill-counter'), actionLog: document.getElementById('action-log'),
                    challengeBossBtn: document.getElementById('challenge-boss-btn'),
                    classSelectionModal: document.getElementById('class-selection-modal'), promotionModal: document.getElementById('promotion-modal'),
                    inventoryList: document.getElementById('inventory-list'), equipmentDisplay: document.getElementById('equipment-display'),
                    newGameBtn: document.getElementById('new-game-btn'), rebirthBtn: document.getElementById('rebirth-btn'),
                    manualSaveBtn: document.getElementById('manual-save-btn'), manualLoadBtn: document.getElementById('manual-load-btn'),
                    manualSaveModal: document.getElementById('manual-save-modal'), manualSaveTextarea: document.getElementById('manual-save-textarea'),
                    closeSaveModalBtn: document.getElementById('close-save-modal-btn'),
                    sellNBtn: document.getElementById('sell-n-btn'), sellRBtn: document.getElementById('sell-r-btn'),
                    rebirthPoints: document.getElementById('rebirth-points'), rebirthAtk: document.getElementById('rebirth-atk'),
                    rebirthDef: document.getElementById('rebirth-def'), rebirthHp: document.getElementById('rebirth-hp'),
                    rebirthGold: document.getElementById('rebirth-gold'), rebirthXp: document.getElementById('rebirth-xp'),
                    globalTooltip: document.getElementById('global-tooltip'),
                    skillPanel: document.getElementById('skill-panel'), skillDisplay: document.getElementById('skill-display'),
                    pointInvestmentDisplay: document.getElementById('point-investment-display'),
                    confirmInvestBtn: document.getElementById('confirm-invest-btn'),
                    resetInvestBtn: document.getElementById('reset-invest-btn'),
                    buyPotion25: document.getElementById('buy-potion-25'), buyPotion50: document.getElementById('buy-potion-50'),
                    buyPotion75: document.getElementById('buy-potion-75'), buyPotion100: document.getElementById('buy-potion-100'),
                };

                function startGame() {
                    if (gameInterval) clearInterval(gameInterval);
                    if (autoSaveInterval) clearInterval(autoSaveInterval);

                    gameState.isRunning = true;
                    if (!gameState.currentMonster) spawnMonster();

                    updateAllUIs();
                    gameInterval = setInterval(gameLoop, 1000);
                    autoSaveInterval = setInterval(autoSaveToLocalStorage, 15000);
                }

                function autoSaveToLocalStorage() {
                    if (!gameState.player || !gameState.isRunning) return;
                    try {
                        const stateToSave = { ...gameState };
                        delete stateToSave.playerTemp; // Don't save transient data
                        const gameStateString = JSON.stringify(stateToSave);
                        localStorage.setItem(SAVE_KEY, gameStateString);
                    } catch (e) {
                        console.error("Auto-save failed:", e);
                        logAction("Auto-save failed. Use Export Save as a backup.", "log-error");
                    }
                }

                function loadFromLocalStorage() {
                    try {
                        const savedState = localStorage.getItem(SAVE_KEY);
                        if (savedState) {
                            const loadedState = JSON.parse(savedState);
                            if (!loadedState.player || !loadedState.player.baseStats) throw new Error("Invalid save.");
                            gameState = deepMerge(getDefaultGameState(), loadedState);
                            resetTransientData();
                            logAction("Game loaded automatically.", 'log-system');
                            return true;
                        }
                    } catch (e) {
                        console.error("Failed to load from localStorage:", e);
                        logAction('Could not auto-load game. Starting new game.', 'log-error');
                        localStorage.removeItem(SAVE_KEY);
                    }
                    return false;
                }

                function manualSave() {
                    if (!gameState.player) return;
                    try {
                        const stateToSave = { ...gameState };
                        delete stateToSave.playerTemp;
                        const encodedSave = btoa(JSON.stringify(stateToSave));
                        UIElements.manualSaveTextarea.value = encodedSave;
                        UIElements.manualSaveModal.style.display = 'flex';
                        UIElements.manualSaveTextarea.select();
                        logAction("Exported save state.", 'log-system');
                    } catch (e) {
                        console.error("Manual save failed:", e);
                        logAction('EXPORT FAILED.', 'log-error');
                    }
                }

                function manualLoad() {
                    const encodedSave = prompt("Please paste your save code:");
                    if (!encodedSave) return;
                    try {
                        const loadedState = JSON.parse(atob(encodedSave));
                        if (!loadedState.player || !loadedState.player.baseStats) throw new Error("Invalid save.");
                        clearInterval(gameInterval); clearInterval(autoSaveInterval);
                        gameState = deepMerge(getDefaultGameState(), loadedState);
                        resetTransientData();
                        logAction("Game imported successfully.", 'log-system');
                        UIElements.classSelectionModal.style.display = 'none';
                        startGame();
                    } catch (e) {
                        console.error("Manual load failed:", e);
                        logAction('IMPORT FAILED: Invalid save code.', 'log-error');
                    }
                }

                function initializeGame() {
                    setupTabs();
                    if (loadFromLocalStorage()) {
                        UIElements.classSelectionModal.style.display = 'none';
                        startGame();
                    } else {
                        logAction("Welcome to Idle RPG. Select your class to begin.", 'log-system');
                        UIElements.classSelectionModal.style.display = 'flex';
                    }
                }

                function selectClass(className) {
                    const classInfo = classes[className];
                    gameState.player = {
                        name: 'Player-' + Math.floor(1000 + Math.random() * 9000),
                        className: className, baseClassName: className,
                        level: 1, xp: 0, xpToNextLevel: 50,
                        statPoints: 5,
                        baseStats: { ...classInfo.base },
                        investedStats: { str: 0, con: 0, def: 0, dex: 0, agl: 0, int: 0, critChance: 0, critDmg: 0 },
                        currentHp: classInfo.base.hp, activeSkills: [],
                    };
                    resetTransientData();
                    UIElements.classSelectionModal.style.display = 'none';
                    logAction(`You have chosen the path of the ${className}.`, 'log-system');
                    startGame();
                }

                function getPlayerTotalStats() {
                    if (!gameState.player) return {};
                    const p = gameState.player;
                    const totals = {};

                    // Sum up base and invested points
                    for (const stat in p.baseStats) {
                        totals[stat] = (p.baseStats[stat] || 0);
                        if (p.investedStats[stat]) {
                            if (stat === 'critChance') totals[stat] += p.investedStats[stat] * 0.002;
                            else if (stat === 'critDmg') totals[stat] += p.investedStats[stat] * 0.005; // 0.5% per point
                            else totals[stat] += p.investedStats[stat];
                        }
                    }

                    // Add equipment stats
                    for (const type in gameState.equipment) {
                        const item = gameState.inventory.find(i => i.id === gameState.equipment[type]);
                        if (item) {
                            for (const stat in STAT_NAMES) {
                                totals[stat] += (item[stat] || 0) + (item.bonusStats?.[stat] || 0);
                            }
                        }
                    }

                    // Calculate derived stats
                    const primaryStat = classes[p.baseClassName].primaryStat;
                    totals.atk = totals[primaryStat] + (gameState.rebirth.bonuses.atk || 0);
                    totals.def += (gameState.rebirth.bonuses.def || 0);
                    totals.hp = 50 + (totals.con * 5) + (gameState.rebirth.bonuses.hp || 0);
                    totals.accuracy = totals.dex * 0.002;
                    totals.evasion = totals.agl * 0.001;

                    // Skill-based modifications
                    if (p.activeSkills.includes('Frenzy')) {
                        const missingHpPercent = 1 - (p.currentHp / totals.hp);
                        const frenzyBonus = Math.floor(missingHpPercent / 0.1) * 0.08;
                        totals.atk *= (1 + frenzyBonus);
                    }
                    if (gameState.playerTemp.standFirm > 0) {
                        totals.def *= 1.30;
                    }

                    if (p.currentHp > totals.hp) p.currentHp = totals.hp;
                    return totals;
                }

                function gameLoop() {
                    if (!gameState.isRunning || !gameState.player || !gameState.currentMonster) return;

                    if (gameState.currentMonster.hp <= 0) { monsterDefeated(); return; }

                    // Player's turn
                    const playerStats = getPlayerTotalStats();
                    let playerDamage = calculateDamage(playerStats, gameState.currentMonster, true);
                    gameState.currentMonster.hp -= playerDamage.damage;
                    logAction(`You hit ${gameState.currentMonster.name} for ${playerDamage.damage} damage.${playerDamage.isCrit ? ' (CRIT!)' : ''}`, 'log-player');

                    if (gameState.currentMonster.hp <= 0) { monsterDefeated(); return; }

                    // Monster's turn
                    let monsterDamage = calculateDamage(gameState.currentMonster, playerStats, false);
                    gameState.player.currentHp -= monsterDamage.damage;
                    logAction(`${gameState.currentMonster.name} hits you for ${monsterDamage.damage} damage.`, 'log-monster');

                    if (gameState.player.currentHp <= 0) playerDefeated();
                    updateAllUIs();
                }

                function calculateDamage(attacker, defender, isPlayerAttacker) {
                    const defenderEvasion = defender.evasion || 0;
                    const attackerAccuracy = attacker.accuracy || 0;
                    const hitChance = Math.max(0.1, Math.min(0.99, 0.9 + attackerAccuracy - defenderEvasion));

                    if (Math.random() > hitChance) {
                        logAction(`${isPlayerAttacker ? 'Your' : (attacker.name + "'s")} attack was evaded!`, 'log-system');
                        return { damage: 0, isCrit: false };
                    }

                    let isCrit = Math.random() < (attacker.critChance || 0);
                    let critMultiplier = isCrit ? (attacker.critDmg || 1.5) : 1;
                    let baseDamage = (attacker.atk || 0) * critMultiplier;
                    let damageReduction = 1 - ((defender.def || 0) / ((defender.def || 0) + 100));
                    let finalDamage = Math.round(baseDamage * damageReduction);

                    return { damage: Math.max(1, finalDamage), isCrit: isCrit };
                }

                function monsterDefeated() {
                    logAction(`You have defeated the ${gameState.currentMonster.name}!`, 'log-system');

                    const goldBonus = 1 + (gameState.rebirth.bonuses.gold / 100);
                    const xpBonus = 1 + (gameState.rebirth.bonuses.xp / 100);
                    const goldGained = Math.round(gameState.currentMonster.gold * goldBonus);
                    const xpGained = Math.round(gameState.currentMonster.xp * xpBonus);

                    gameState.gold += goldGained;
                    gameState.player.xp += xpGained;
                    logAction(`You gained ${goldGained} gold and ${xpGained} XP.`, 'log-drop');

                    if (Math.random() < gameState.currentMonster.dropChance) {
                        generateItemDrop(gameState.currentMonster);
                    }

                    gameState.kills++;
                    if (gameState.currentMonster.isBoss) {
                        gameState.wave++;
                        gameState.kills = 0;
                        UIElements.challengeBossBtn.disabled = true;
                    }

                    if (gameState.kills >= 10 && !gameState.currentMonster.isBoss) UIElements.challengeBossBtn.disabled = false;
                    if (gameState.player.xp >= gameState.player.xpToNextLevel) levelUp();

                    spawnMonster();
                }

                function playerDefeated() {
                    gameState.player.currentHp = 0;
                    logAction('You have been defeated!', 'log-monster');
                    const xpPenalty = Math.round(gameState.player.xpToNextLevel * 0.10);
                    gameState.player.xp = Math.max(0, gameState.player.xp - xpPenalty);
                    logAction(`You lose ${xpPenalty} XP.`, 'log-error');
                    gameState.player.currentHp = getPlayerTotalStats().hp * 0.5;
                    logAction(`You revive with 50% health.`, 'log-system');
                    if (gameState.currentMonster.isBoss) {
                        UIElements.challengeBossBtn.disabled = true;
                        spawnMonster();
                    }
                }

                function generateItemDrop(monster) {
                    if (gameState.inventory.length >= gameState.maxInventorySize) {
                        logAction('Inventory is full!', 'log-system'); return;
                    }
                    const itemType = itemData.types[Math.floor(Math.random() * itemData.types.length)];
                    const playerBaseClass = gameState.player.baseClassName;
                    const possibleNames = itemData.names[itemType][playerBaseClass];
                    const baseName = possibleNames[Math.floor(Math.random() * possibleNames.length)];
                    const prefix = itemData.names.prefixes.Balanced[Math.floor(Math.random() * itemData.names.prefixes.Balanced.length)];

                    let rarityKey;
                    const rand = Math.random();
                    if (monster.isBoss) {
                        if (rand < 0.4) rarityKey = 'R'; else if (rand < 0.8) rarityKey = 'SR'; else if (rand < 0.98) rarityKey = 'SSR'; else rarityKey = 'UR';
                    } else if (monster.isElite) {
                        if (rand < 0.5) rarityKey = 'R'; else if (rand < 0.85) rarityKey = 'SR'; else rarityKey = 'SSR';
                    } else {
                        if (rand < 0.8) rarityKey = 'N'; else rarityKey = 'R';
                    }
                    if (!rarityKey) rarityKey = 'N';

                    const rarityInfo = itemData.rarities[rarityKey];
                    const newItem = {
                        id: Date.now() + Math.random(),
                        name: `${prefix} ${baseName}`,
                        type: itemType,
                        rarity: rarityKey,
                        classReq: playerBaseClass,
                        bonusStats: {}
                    };

                    // Add base stats
                    for (const stat in itemData.baseStats[itemType]) {
                        newItem[stat] = Math.round(itemData.baseStats[itemType][stat] * rarityInfo.statMod);
                    }

                    // Add bonus stats
                    let availableBonusStats = [...itemData.bonusStatPool];
                    for (let i = 0; i < rarityInfo.bonusStats; i++) {
                        if (availableBonusStats.length === 0) break;
                        const statIndex = Math.floor(Math.random() * availableBonusStats.length);
                        const bonusStat = availableBonusStats.splice(statIndex, 1)[0];
                        let value;
                        if (['critChance', 'critDmg'].includes(bonusStat)) {
                            value = (Math.random() * 0.05 + 0.01) * rarityInfo.statMod;
                        } else {
                            value = Math.round((Math.random() * 4 + 1) * rarityInfo.statMod);
                        }
                        newItem.bonusStats[bonusStat] = value;
                    }

                    gameState.inventory.push(newItem);
                    const color = rarityInfo.color;
                    logAction(`You found a [<span style="color:${color}">${rarityKey}</span>] <span style="color:${color}">${newItem.name}</span>!`, 'log-drop');
                    updateInventoryUI();
                }

                function spawnMonster(isBoss = false) {
                    gameState.isRunning = true;
                    let monsterTemplate;
                    if (isBoss) {
                        monsterTemplate = monsters.bosses[(gameState.wave - 1) % monsters.bosses.length];
                    } else {
                        const rand = Math.random();
                        if (gameState.wave > 1 && rand < 0.15) {
                            monsterTemplate = monsters.elite[Math.floor(Math.random() * monsters.elite.length)];
                        } else {
                            monsterTemplate = monsters.regular[Math.floor(Math.random() * monsters.regular.length)];
                        }
                    }

                    const scale = Math.pow(1.4, gameState.wave - 1);
                    gameState.currentMonster = {
                        ...monsterTemplate,
                        hp: Math.round(monsterTemplate.baseHp * scale),
                        maxHp: Math.round(monsterTemplate.baseHp * scale),
                        atk: Math.round(monsterTemplate.baseAtk * scale),
                        def: Math.round(monsterTemplate.baseDef * scale),
                        evasion: monsterTemplate.baseEvasion,
                        accuracy: 0,
                        gold: Math.round(monsterTemplate.gold * scale),
                        xp: Math.round(monsterTemplate.xp * Math.pow(1.05, gameState.wave - 1)),
                        isBoss: isBoss,
                        debuffs: {},
                    };
                    logAction(`A wild ${gameState.currentMonster.name} appears!`, 'log-system');
                    updateUI();
                }

                function levelUp() {
                    gameState.player.level++;
                    gameState.player.xp = 0;
                    gameState.player.xpToNextLevel = Math.round(gameState.player.xpToNextLevel * 1.25);
                    const pointsGained = Math.floor(Math.random() * 3) + 5; // 5-7 points
                    gameState.player.statPoints += pointsGained;

                    // Apply class growth
                    const p = gameState.player;
                    let growth = { ...classes[p.baseClassName].growth };
                    const promoAdjust = promotionGrowthAdjustments[p.className];
                    if (promoAdjust) {
                        for (const stat in promoAdjust) {
                            growth[stat] = (growth[stat] || 0) + promoAdjust[stat];
                        }
                    }
                    for (const stat in growth) {
                        p.baseStats[stat] += growth[stat];
                    }

                    gameState.player.currentHp = getPlayerTotalStats().hp;
                    logAction(`LEVEL UP! You are now level ${gameState.player.level}. Gained ${pointsGained} stat points.`, 'log-system');
                    logAction('Health fully restored!', 'log-system');
                    if (gameState.player.level >= 70) UIElements.rebirthBtn.style.display = 'block';

                    const promotions = classes[gameState.player.baseClassName]?.promotions;
                    if (promotions && promotions[gameState.player.level]) {
                        const choiceList = Array.isArray(promotions[gameState.player.level]) ? promotions[gameState.player.level] : promotions[gameState.player.level][gameState.player.className];
                        if (choiceList) showPromotionModal(choiceList);
                    }
                    updateAllUIs();
                }

                function showPromotionModal(choices) {
                    gameState.isRunning = false;
                    const promotionChoices = document.getElementById('promotion-choices');
                    promotionChoices.innerHTML = '';
                    choices.forEach(choice => {
                        const btn = document.createElement('button');
                        btn.textContent = choice;
                        btn.onclick = () => {
                            gameState.player.className = choice;
                            logAction(`You have been promoted to ${choice}!`, 'log-system');
                            gameState.player.currentHp = getPlayerTotalStats().hp;
                            UIElements.promotionModal.style.display = 'none';
                            gameState.isRunning = true;
                            updateAllUIs();
                        };
                        promotionChoices.appendChild(btn);
                    });
                    UIElements.promotionModal.style.display = 'flex';
                }

                function updateUI() {
                    if (!gameState.player) return;
                    const totalStats = getPlayerTotalStats();
                    UIElements.playerName.textContent = gameState.player.name; UIElements.playerClass.textContent = gameState.player.className;
                    UIElements.playerLevel.textContent = gameState.player.level;
                    UIElements.playerHpText.textContent = `${Math.ceil(gameState.player.currentHp)} / ${Math.round(totalStats.hp)}`;
                    UIElements.playerHpFill.style.width = `${(gameState.player.currentHp / totalStats.hp) * 100}%`;
                    UIElements.playerXpText.textContent = `${gameState.player.xp} / ${gameState.player.xpToNextLevel}`;
                    UIElements.playerXpFill.style.width = `${(gameState.player.xp / gameState.player.xpToNextLevel) * 100}%`;
                    UIElements.playerAtk.textContent = Math.round(totalStats.atk); UIElements.playerDef.textContent = Math.round(totalStats.def);
                    UIElements.playerAccuracy.textContent = `${(totalStats.accuracy * 100).toFixed(1)}%`;
                    UIElements.playerEvasion.textContent = `${(totalStats.evasion * 100).toFixed(1)}%`;
                    UIElements.playerCritChance.textContent = `${(totalStats.critChance * 100).toFixed(1)}%`;
                    UIElements.playerCritDmg.textContent = `${(totalStats.critDmg * 100).toFixed(0)}%`;
                    UIElements.playerGold.textContent = gameState.gold;

                    if (gameState.currentMonster) {
                        UIElements.monsterName.textContent = gameState.currentMonster.name;
                        UIElements.monsterHpText.textContent = `${Math.ceil(gameState.currentMonster.hp)} / ${gameState.currentMonster.maxHp}`;
                        UIElements.monsterHpFill.style.width = `${(gameState.currentMonster.hp / gameState.currentMonster.maxHp) * 100}%`;
                    }
                    UIElements.waveCounter.textContent = gameState.wave; UIElements.killCounter.textContent = gameState.kills;
                    UIElements.rebirthPoints.textContent = gameState.rebirth.points; UIElements.rebirthAtk.textContent = gameState.rebirth.bonuses.atk;
                    UIElements.rebirthDef.textContent = gameState.rebirth.bonuses.def;
                    UIElements.rebirthHp.textContent = gameState.rebirth.bonuses.hp;
                    UIElements.rebirthGold.textContent = gameState.rebirth.bonuses.gold;
                    UIElements.rebirthXp.textContent = gameState.rebirth.bonuses.xp;

                    for (const key of [25, 50, 75, 100]) {
                        const cost = gameState.potionCosts[`p${key}`];
                        const btn = UIElements[`buyPotion${key}`];
                        btn.textContent = `Buy (${cost}G)`;
                        btn.disabled = gameState.gold < cost || gameState.player.currentHp >= totalStats.hp;
                    }
                }

                function updatePointInvestmentUI() {
                    const display = UIElements.pointInvestmentDisplay;
                    display.innerHTML = '';
                    if (!gameState.player) return;

                    const p = gameState.player;
                    const allocation = gameState.playerTemp.pointAllocation;
                    const totalPending = Object.values(allocation).reduce((a, b) => a + b, 0);
                    const pointsAvailable = p.statPoints - totalPending;

                    UIElements.playerStatPoints.textContent = `${p.statPoints} (${pointsAvailable} avail)`;

                    for (const stat in p.investedStats) {
                        const statDiv = document.createElement('div');
                        statDiv.className = 'point-investment-stat';

                        const currentVal = (p.baseStats[stat] || 0) +
                            (stat === 'critChance' ? p.investedStats[stat] * 0.002 :
                                stat === 'critDmg' ? p.investedStats[stat] * 0.005 :
                                p.investedStats[stat]);

                        const pendingPoints = allocation[stat];
                        const pendingValue = (stat === 'critChance' ? pendingPoints * 0.002 :
                            stat === 'critDmg' ? pendingPoints * 0.005 :
                            pendingPoints);

                        const futureVal = currentVal + pendingValue;

                        let displayCurrent, displayFuture;
                        if (['critChance', 'critDmg'].includes(stat)) {
                            displayCurrent = `${(currentVal * 100).toFixed(1)}%`;
                            displayFuture = `${(futureVal * 100).toFixed(1)}%`;
                        } else {
                            displayCurrent = Math.round(currentVal);
                            displayFuture = Math.round(futureVal);
                        }

                        statDiv.innerHTML = `
                            <span class="stat-label">${STAT_NAMES[stat]}: <span class="stat-value">${displayCurrent}</span>
                                ${pendingPoints > 0 ? ` -> ${displayFuture}` : ''}
                            </span>
                            <div class="investment-controls">
                                <button class="btn-minus" data-stat="${stat}">-</button>
                                <span class="pending-points">${pendingPoints}</span>
                                <button class="btn-plus" data-stat="${stat}">+</button>
                            </div>
                        `;
                        const plusBtn = statDiv.querySelector('.btn-plus');
                        const minusBtn = statDiv.querySelector('.btn-minus');
                        plusBtn.disabled = pointsAvailable <= 0;
                        minusBtn.disabled = pendingPoints <= 0;

                        plusBtn.onclick = () => handlePointAllocation(stat, 1);
                        minusBtn.onclick = () => handlePointAllocation(stat, -1);

                        display.appendChild(statDiv);
                    }
                    UIElements.confirmInvestBtn.disabled = totalPending <= 0;
                    UIElements.resetInvestBtn.disabled = totalPending <= 0;
                }

                function handlePointAllocation(stat, amount) {
                    if (!gameState.player) return;
                    const allocation = gameState.playerTemp.pointAllocation;
                    const totalPending = Object.values(allocation).reduce((a, b) => a + b, 0);

                    if (amount > 0 && gameState.player.statPoints - totalPending > 0) {
                        allocation[stat]++;
                    } else if (amount < 0 && allocation[stat] > 0) {
                        allocation[stat]--;
                    }
                    updateAllUIs();
                }

                function confirmPointInvestment() {
                    if (!gameState.player) return;
                    const allocation = gameState.playerTemp.pointAllocation;
                    const totalToSpend = Object.values(allocation).reduce((a, b) => a + b, 0);

                    if (totalToSpend > 0 && gameState.player.statPoints >= totalToSpend) {
                        for (const stat in allocation) {
                            gameState.player.investedStats[stat] += allocation[stat];
                        }
                        gameState.player.statPoints -= totalToSpend;
                        logAction(`Invested ${totalToSpend} points.`, 'log-system');
                        resetPointInvestment(); // Also updates UI
                    }
                }

                function resetPointInvestment() {
                    for (const stat in gameState.playerTemp.pointAllocation) {
                        gameState.playerTemp.pointAllocation[stat] = 0;
                    }
                    updateAllUIs();
                }


                function updateInventoryUI() {
                    const list = UIElements.inventoryList;
                    list.innerHTML = '';
                    const equippedIds = Object.values(gameState.equipment);
                    gameState.inventory.forEach(item => {
                        const isEquipped = equippedIds.includes(item.id);
                        const rarityColor = itemData.rarities[item.rarity].color;

                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'inventory-item';
                        itemDiv.innerHTML = `
                            <div class="inventory-item-info" data-item-id="${item.id}">
                                <span style="color: ${rarityColor};">${item.name}</span>
                                ${isEquipped ? '<span class="equipped-tag">[Equipped]</span>' : ''}
                            </div>
                            <div class="inventory-item-actions">
                                <button class="equip-btn" data-item-id="${item.id}">${isEquipped ? 'Unequip' : 'Equip'}</button>
                                <button class="sell-btn" data-item-id="${item.id}">Sell</button>
                            </div>
                        `;
                        list.appendChild(itemDiv);
                    });

                    list.querySelectorAll('.inventory-item-info').forEach(el => {
                        el.onmouseover = (e) => {
                            const item = gameState.inventory.find(i => i.id == e.currentTarget.dataset.itemId);
                            if (item) showTooltip(e, item, equippedIds.includes(item.id));
                        };
                        el.onmouseout = hideTooltip;
                    });
                    list.querySelectorAll('.equip-btn').forEach(btn => {
                        btn.onclick = (e) => {
                            const item = gameState.inventory.find(i => i.id == e.currentTarget.dataset.itemId);
                            if (item) {
                                if (equippedIds.includes(item.id)) unequipItem(item.type);
                                else equipItem(item);
                            }
                        };
                    });
                    list.querySelectorAll('.sell-btn').forEach(btn => {
                        btn.onclick = (e) => sellItem(e.currentTarget.dataset.itemId);
                        btn.disabled = equippedIds.includes(parseFloat(btn.dataset.itemId));
                    });
                }

                function updateEquipmentUI() {
                    const display = UIElements.equipmentDisplay;
                    display.innerHTML = '';
                    ['weapon', 'body', 'legs'].forEach(type => {
                        const item = gameState.inventory.find(i => i.id === gameState.equipment[type]);
                        const itemSlot = document.createElement('div');
                        itemSlot.className = 'equipment-slot-display';
                        let nameHTML = '---';
                        if (item) {
                            nameHTML = `<span style="color: ${itemData.rarities[item.rarity].color};">${item.name}</span>`;
                            itemSlot.onclick = () => unequipItem(type);
                            itemSlot.onmouseover = (e) => showTooltip(e, item, true);
                            itemSlot.onmouseout = hideTooltip;
                        }
                        itemSlot.innerHTML = `<strong>${type.charAt(0).toUpperCase() + type.slice(1)}:</strong> ${nameHTML}`;
                        display.appendChild(itemSlot);
                    });
                }

                function showTooltip(event, item, isEquipped) {
                    clearTimeout(tooltipHideTimer);
                    const tooltip = UIElements.globalTooltip;
                    let content = `<strong style="color: ${itemData.rarities[item.rarity].color};">${item.name} (${item.type})</strong><br>`;
                    content += `Rarity: ${item.rarity} | Class: ${item.classReq}<br>----<br>`;

                    for (const stat in STAT_NAMES) {
                        const baseVal = item[stat] || 0;
                        const bonusVal = item.bonusStats?.[stat] || 0;
                        const totalVal = baseVal + bonusVal;
                        if (totalVal > 0) {
                            const displayVal = (['critChance', 'critDmg'].includes(stat)) ? `+${(totalVal * 100).toFixed(1)}%` : `+${Math.round(totalVal)}`;
                            content += `${STAT_NAMES[stat]}: ${displayVal}<br>`;
                        }
                    }
                    content += `----<br>Sell Value: ${itemData.rarities[item.rarity].value}G`;
                    tooltip.innerHTML = content;

                    tooltip.style.display = 'block';
                    const targetRect = event.currentTarget.getBoundingClientRect();
                    const tooltipRect = tooltip.getBoundingClientRect();
                    let top = targetRect.top - tooltipRect.height - 5;
                    let left = targetRect.left + (targetRect.width / 2) - (tooltipRect.width / 2);
                    if (top < 0) top = targetRect.bottom + 5;
                    if (left < 0) left = 5;
                    if (left + tooltipRect.width > window.innerWidth) left = window.innerWidth - tooltipRect.width - 5;
                    tooltip.style.top = `${top}px`;
                    tooltip.style.left = `${left}px`;
                }

                function hideTooltip() {
                    clearTimeout(tooltipHideTimer);
                    tooltipHideTimer = setTimeout(() => { UIElements.globalTooltip.style.display = 'none'; }, 200);
                }

                function equipItem(itemToEquip) {
                    if (itemToEquip.classReq !== gameState.player.baseClassName) {
                        logAction(`Cannot equip: ${itemToEquip.name}. Requires ${itemToEquip.classReq} class.`, 'log-error');
                        return;
                    }
                    gameState.equipment[itemToEquip.type] = itemToEquip.id;
                    logAction(`Equipped [${itemToEquip.rarity}] ${itemToEquip.name}.`, 'log-system');
                    updateAllUIs();
                }

                function unequipItem(itemType) {
                    const itemToUnequip = gameState.inventory.find(item => item.id === gameState.equipment[itemType]);
                    gameState.equipment[itemType] = null;
                    if (itemToUnequip) logAction(`Unequipped [${itemToUnequip.rarity}] ${itemToUnequip.name}.`, 'log-system');
                    updateAllUIs();
                }

                function sellItem(itemId) {
                    const itemIndex = gameState.inventory.findIndex(i => i.id == itemId);
                    if (itemIndex === -1) return;
                    const item = gameState.inventory[itemIndex];
                    if (Object.values(gameState.equipment).includes(item.id)) {
                        logAction("Cannot sell an equipped item.", 'log-error'); return;
                    }
                    const sellValue = itemData.rarities[item.rarity].value;
                    gameState.gold += sellValue;
                    gameState.inventory.splice(itemIndex, 1);
                    logAction(`Sold [${item.rarity}] ${item.name} for ${sellValue}G.`, 'log-system');
                    hideTooltip();
                    updateAllUIs();
                }

                function logAction(message, typeClass) {
                    const p = document.createElement('p');
                    p.innerHTML = message;
                    if (typeClass) p.classList.add(typeClass);
                    UIElements.actionLog.appendChild(p);
                    UIElements.actionLog.scrollTop = UIElements.actionLog.scrollHeight;
                }

                function updateAllUIs() { updateUI(); updateInventoryUI(); updateEquipmentUI(); updatePointInvestmentUI(); }

                function resetTransientData() {
                    gameState.playerTemp = {
                        pointAllocation: { str: 0, con: 0, def: 0, dex: 0, agl: 0, int: 0, critChance: 0, critDmg: 0 }
                    };
                    if (gameState.currentMonster) gameState.currentMonster.debuffs = {};
                }

                function handleNewGame() {
                    clearInterval(gameInterval); clearInterval(autoSaveInterval);
                    localStorage.removeItem(SAVE_KEY);
                    const rebirthData = gameState.rebirth;
                    gameState = getDefaultGameState();
                    gameState.rebirth = rebirthData;
                    UIElements.actionLog.innerHTML = '';
                    logAction('The world is born anew. Choose your class.', 'log-system');
                    UIElements.rebirthBtn.style.display = 'none';
                    UIElements.classSelectionModal.style.display = 'flex';
                    updateAllUIs();
                }

                function handleRebirth() {
                    if (!gameState.player || gameState.player.level < 70) return;
                    if (confirm('Are you sure you want to rebirth?')) {
                        const pointsGained = Math.floor((gameState.player.level - 69) * 1.5 + gameState.wave * 2);
                        clearInterval(gameInterval); clearInterval(autoSaveInterval);
                        localStorage.removeItem(SAVE_KEY);
                        const rebirthData = gameState.rebirth;
                        rebirthData.points += pointsGained;
                        gameState = getDefaultGameState();
                        gameState.rebirth = rebirthData;
                        logAction(`You have been reborn! Gained ${pointsGained} Rebirth Points.`, 'log-system');
                        UIElements.rebirthBtn.style.display = 'none';
                        UIElements.classSelectionModal.style.display = 'flex';
                        updateAllUIs();
                    }
                }

                function investRebirthPoint(stat) {
                    if (gameState.rebirth.points > 0) {
                        gameState.rebirth.points--;
                        if (['gold', 'xp'].includes(stat)) gameState.rebirth.bonuses[stat] += 1;
                        else gameState.rebirth.bonuses[stat] += (stat === 'hp' ? 5 : 1);
                        updateAllUIs();
                    }
                }

                function sellItemsByRarity(rarity) {
                    let soldCount = 0; let goldEarned = 0;
                    const equippedIds = Object.values(gameState.equipment);
                    const itemsToKeep = gameState.inventory.filter(item => {
                        if (item.rarity === rarity && !equippedIds.includes(item.id)) {
                            goldEarned += itemData.rarities[item.rarity].value; soldCount++; return false;
                        }
                        return true;
                    });
                    if (soldCount > 0) {
                        gameState.inventory = itemsToKeep; gameState.gold += goldEarned;
                        logAction(`Sold ${soldCount} [${rarity}] items for ${goldEarned}G.`, 'log-system');
                        updateAllUIs();
                    } else {
                        logAction(`No unequipped [${rarity}] items to sell.`, 'log-system');
                    }
                }

                function buyPotion(percent) {
                    const cost = gameState.potionCosts[`p${percent}`];
                    const totalStats = getPlayerTotalStats();
                    if (gameState.gold >= cost && gameState.player.currentHp < totalStats.hp) {
                        gameState.gold -= cost;
                        const healAmount = totalStats.hp * (percent / 100);
                        gameState.player.currentHp = Math.min(totalStats.hp, gameState.player.currentHp + healAmount);
                        gameState.potionCosts[`p${percent}`] = Math.round(cost * 1.05);
                        logAction(`You drink a potion, restoring health.`, 'log-system');
                        updateUI();
                    }
                }


                function isObject(item) { return (item && typeof item === 'object' && !Array.isArray(item)); }
                function deepMerge(target, source) {
                    let output = { ...target };
                    if (isObject(target) && isObject(source)) {
                        Object.keys(source).forEach(key => {
                            if (isObject(source[key]) && key in target && isObject(target[key])) {
                                output[key] = deepMerge(target[key], source[key]);
                            } else {
                                output[key] = source[key];
                            }
                        });
                    }
                    return output;
                }

                function setupTabs() {
                    document.querySelectorAll('.tab-button').forEach(button => {
                        button.addEventListener('click', () => {
                            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                            button.classList.add('active');
                            const tabId = button.getAttribute('data-tab');
                            document.querySelectorAll('.tab-content').forEach(content => {
                                content.classList.toggle('active', content.id === `tab-content-${tabId}`);
                            });
                        });
                    });
                }

                // --- EVENT LISTENERS ---
                document.getElementById('select-warrior').onclick = () => selectClass('Warrior');
                document.getElementById('select-rogue').onclick = () => selectClass('Rogue');
                document.getElementById('select-wizard').onclick = () => selectClass('Wizard');
                UIElements.manualSaveBtn.onclick = manualSave;
                UIElements.manualLoadBtn.onclick = manualLoad;
                UIElements.closeSaveModalBtn.onclick = () => { UIElements.manualSaveModal.style.display = 'none'; };
                UIElements.newGameBtn.onclick = handleNewGame;
                UIElements.rebirthBtn.onclick = handleRebirth;
                UIElements.challengeBossBtn.onclick = () => {
                    spawnMonster(true);
                    gameState.player.currentHp = getPlayerTotalStats().hp;
                    UIElements.challengeBossBtn.disabled = true;
                    updateUI();
                };
                UIElements.buyPotion25.onclick = () => buyPotion(25);
                UIElements.buyPotion50.onclick = () => buyPotion(50);
                UIElements.buyPotion75.onclick = () => buyPotion(75);
                UIElements.buyPotion100.onclick = () => buyPotion(100);
                document.querySelectorAll('#tab-content-rebirth .rebirth-stat button').forEach(btn => {
                    btn.onclick = () => investRebirthPoint(btn.dataset.rebirth);
                });
                UIElements.sellNBtn.onclick = () => sellItemsByRarity('N');
                UIElements.sellRBtn.onclick = () => sellItemsByRarity('R');
                UIElements.globalTooltip.onmouseover = () => clearTimeout(tooltipHideTimer);
                UIElements.globalTooltip.onmouseout = hideTooltip;
                UIElements.confirmInvestBtn.onclick = confirmPointInvestment;
                UIElements.resetInvestBtn.onclick = resetPointInvestment;

                initializeGame();
            });
        </script>
</body>

</html>
